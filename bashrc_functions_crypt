#!/bin/bash
#
# Copyright (C) 2016-2019, Andrew Kroshko, all rights reserved.
#
# Author: Andrew Kroshko
# Maintainer: Andrew Kroshko <akroshko.public+devel@gmail.com>
# Created: Tue May 25, 2016
# Version: 20191209
# URL: https://github.com/akroshko/crypt-profiles
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see http://www.gnu.org/licenses/.

################################################################################
# dealing with keys and agents

# TODO: don't think I need to specify working profile, can I do better? do I just need a temp working profile?
crypt-create-profile () {
    # TODO: what does a crypt-profile actually look like
    #       -master, original one, used for creating subkeys
    #       -primary, contains the files that get synced
    #       -working, gpg working directory, things are symlinked into here
    #       authorized_keys and public keys, figure out how to manage
    # TODO: ensure all public keys are mutually imported appropriately
    #       need a proper way to detect key profiles? do I want public keys mutually imported everywhere?
    #       put somewhere universal and import everywhere?
    # TODO: also manage disk and container LUKS encryption keys
    #
    # TODO: automate a bit better, test final product is good
    #       this is a really good candidate for stand-alone script and set -e
    #
    # References:
    #   http://spin.atomicobject.com/2013/10/23/secure-gpg-keys/
    #   http://spin.atomicobject.com/2013/11/24/secure-gpg-keys-guide/
    local USAGE="crypt-create-profile <<master location>> <<primary location>> <<working location>>"
    if [[ -z "$1" ]]; then
        yell "Empty master location specified!"
        return 1
    fi
    if [[ -z "$2" ]]; then
        yell "Empty primary location specified!"
        return 1
    fi
    if [[ -z "$3" ]]; then
        yell "Empty working location specified!"
        return 1
    fi
    killall-agents
    local MASTERPROFILE="$1"
    mkdir -p "$MASTERPROFILE"
    fix-crypt-permissions "$MASTERPROFILE"
    # do no make this directory because we use cp
    local PRIMARYPROFILE="$2"
    local WORKINGPROFILE="$3"
    # generate a new gpg key first
    # first ask for a the master password
    # XXXX: this is insecure but I need to use the password further in the script?
    # TODO: use pinentry to get password
    msg "++++ WARNING: password shown in cleartext for now and must be the same as that entered into pinentry later."
    msg "Enter the new GPG key password:"
    read GPGPASSWORD
    msg "Enter the new GPG key password again:"
    read GPGPASSWORD2
    msg "Enter the recipient:"
    read RECIPIENT
    if [[ ! "$GPGPASSWORD" == "$GPGPASSWORD2" ]]; then
        warn "Passwords are different!!!"
        return 1
    fi
    # XXXX: if true for debugging purposes
    if true; then
        h1
        h2 "Generating initial key:"
        msg "Recommend RSA (set your own capabilities), toggle until only capability is certify, 4096 bits, no expiry for now."
        # is it useful to have a special phrase in comment?
        # echo "Comment should include phrase ..." 1>&2
        echo ""
        # TODO: retry if fail to build public key, e.g., password is bad
        DISPLAY= gpg-batch --homedir "$MASTERPROFILE" --expert --gen-key
        # put gpg password into the secrets file
        DISPLAY= echo "$GPGPASSWORD" | gpg-batch --homedir "$MASTERPROFILE" --recipient "$RECIPIENT" --encrypt --passphrase "$GPGPASSWORD" --output "$KEYSLOCATION/secrets.txt.gpg" -
        # add a new subkey to the master profile
        h1
        msg "Use the addkey command twice:"
        msg "Recommend RSA (set your own capabilities), toggle until only capability is sign, 4096 bits, no expiry for now."
        msg "Recommend RSA (set your own capabilities), toggle until only capability is encrypt, 4096 bits, no expiry for now."
        msg "Use the save command to finish"
        echo ""
        # TODO: retry if fail
        DISPLAY= gpg-batch --homedir "$MASTERPROFILE" --expert --edit-key "$RECIPIENT"
    fi
    # XXXX: if true for debugging purposes
    if true; then
        # generate ssh keys, possibly want this to be a little better
        # TODO: setup authorized keys later, maybe have a way to see who can mutually login to whom
        # generate a password for id_rsa
        crypt-create-rsa-keys "$MASTERPROFILE" "$RECIPIENT" "$GPGPASSWORD"
        # generate a password for id_ed25519
        crypt_create-ed25519-keys "$MASTERPROFILE" "$RECIPIENT" "$GPGPASSWORD"
    fi
    # XXXX: if true for debugging purposes
    if true; then
        cp -r "$MASTERPROFILE" "$WORKINGPROFILE"
        fix-crypt-permissions "$WORKINGPROFILE"
        gpg-batch --yes --homedir "$WORKINGPROFILE" --export-secret-subkeys "$RECIPIENT" --output "$HOME/crypt-profiles-secret-keys"
        h1
        msg "Answer (y)es to delete secret key"
        echo ""
        gpg2 --homedir "$WORKINGPROFILE" --delete-secret-key "$RECIPIENT"
        gpg2 --homedir "$WORKINGPROFILE" --import "$HOME/crypt-profiles-secret-keys"
        # create the actually working profile
        # TODO: add some checks here
        mkdir -p "$PRIMARYPROFILE"
        \mv --no-clobber "$WORKINGPROFILE/pubring.gpg" "$PRIMARYPROFILE"
        ln -s "$PRIMARYPROFILE/pubring.gpg" "$WORKINGPROFILE/pubring.gpg"
        \mv --no-clobber "$WORKINGPROFILE/secring.gpg" "$PRIMARYPROFILE"
        ln -s "$PRIMARYPROFILE/secring.gpg" "$WORKINGPROFILE/secring.gpg"
        \mv --no-clobber "$WORKINGPROFILE/trustdb.gpg" "$PRIMARYPROFILE"
        ln -s "$PRIMARYPROFILE/trustdb.gpg" "$WORKINGPROFILE/trustdb.gpg"
        \mv --no-clobber "$MASTERPROFILE/id_rsa.txt.gpg" "$PRIMARYPROFILE"
        \mv --no-clobber "$MASTERPROFILE/id_rsa" "$PRIMARYPROFILE"
        \mv --no-clobber "$MASTERPROFILE/id_rsa.pub" "$PRIMARYPROFILE"
        \mv --no-clobber "$MASTERPROFILE/id_ed25519.txt.gpg" "$PRIMARYPROFILE"
        \mv --no-clobber "$MASTERPROFILE/id_ed25519" "$PRIMARYPROFILE"
        \mv --no-clobber "$MASTERPROFILE/id_ed25519.pub" "$PRIMARYPROFILE"
        # TODO: not sure I need this or where the best place is
        # fix-gpg-ssh-permissions
    fi
}

crypt-create-rsa-keys () {
    # fail without leaving dangling files when some command does not work
    if [[ -z "$1" || -z "$2" || -z "$2" ]];then
        echo "Must specify <<MASTERPROFILE>> <<RECIPIENT>> <<GPGPASSWORD>>" 1>&2
        return 1
    fi
    local MASTERPROFILE="$1"
    local RECIPIENT="$2"
    local GPGPASSWORD="$3"
    local PASSWORD=$(super-password)
    # create the ssh key
    ssh-keygen-rsa "$MASTERPROFILE" "$PASSWORD"
    # use gpg key to encrypt the password
    DISPLAY= echo "$PASSWORD" | gpg-batch --yes --homedir "$MASTERPROFILE" --recipient "$RECIPIENT" --encrypt --passphrase "$GPGPASSWORD" --output "$MASTERPROFILE/id_rsa.txt.gpg" -
}

crypt-create-ed25519-keys () {
    # fail without leaving dangling files when some command does not work
    if [[ -z "$1" || -z "$2" || -z "$2" ]];then
        echo "Must specify <<MASTERPROFILE>> <<RECIPIENT>> <<GPGPASSWORD>>" 1>&2
        return 1
    fi
    local MASTERPROFILE="$1"
    local RECIPIENT="$2"
    local GPGPASSWORD="$3"
    # generate a password id_ed25519
    local PASSWORD=$(super-password)
    # create the ssh key
    ssh-keygen-ed25519 "$MASTERPROFILE" "$PASSWORD"
    # use gpg key to encrypt the password
    DISPLAY= echo "$PASSWORD" | gpg-batch --yes --homedir "$MASTERPROFILE" --recipient "$RECIPIENT" --encrypt --passphrase "$GPGPASSWORD" --output "$MASTERPROFILE/id_ed25519.txt.gpg" -
}

# TODO: will eventually want to be able to modify secret files
# TODO: want to be able to list and delete secrets too
# TODO: make sure this aborts properly
# TODO: have a more universal way of doing this
crypt-add-secret-to-profile () {
    # TODO: this is kind of a standard thing
    # TODO: add check that current profile and locations sync up
    # TODO: check that crypt is working
    if [[ -z "$1" ]]; then
        yell "Empty primary location specified!"
        msg "crypt-add-secret-to-profile <<primary location>> <<secret name>"
        return 1
    fi
    if [[ -z "$2" ]]; then
        yell "Empty secret name specified!"
        msg "crypt-add-secret-to-profile <<primary location>> <<secret name>"
        return 1
    fi
    # XXXX: must keep crypt active, possibly fix permissions
    local PRIMARYPROFILE="$1"
    local SECRETNAME="$2"
    # TODO: can I do this without??? maybe secrets should be symmetrically encrypted
    local RECIPIENT="$CRYPTGPGUSER"
    # enter secret
    msg "++++ WARNING: secret will be shown in cleartext."
    msg "Enter the secret on one line: "
    read THESECRET
    msg "Enter the secret again on one line: "
    read THESECRET2
    if [[ ! "$THESECRET" == "$THESECRET2" ]]; then
        warn "The secrets are different!!!"
        return 1
    fi
    # get the password from the current secrets
    local GPGPASSPHRASE=$(gpg-batch --decrypt ~/.secrets/secrets.txt.gpg 2>/dev/null | head -n 1)
    # create the secret
    if [[ -n "$THESECRET" && -n "$RECIPIENT" && -n "$GPGPASSPHRASE" && -n "$SECRETNAME" ]]; then
        # TODO: there is an issue with message "You need a passphrase to unlock the secret key for "
        #       issue temporarily solved by using --batch when decrypting
        echo "$THESECRET" | gpg2 --recipient "$RECIPIENT" --encrypt --passphrase "$GPGPASSPHRASE" --output "$PRIMARYPROFILE/$SECRETNAME"-secrets.txt.gpg -
    else
        yell "Something went wrong before final encryption!"
    fi
}

# TODO: flush this out
crypt-replace-subkeys () {
    yell "Not implemented yet!"
    false
}

crypt-profile-switch () {
    # switch to a new crypt-profile-
    local USAGE="Usage: crypt-profile-switch <<crypt-profile primary location>> <<crypt-profile working location>>"
    if [[ -z "$1" ]]; then
        yell "No specified primary path!"
        echo $USAGE
        return 1
    fi
    if [[ -z "$2" ]]; then
        yell "No specified working path!"
        echo $USAGE
        return 1
    fi
    while read -r -t 0;do read -r; done
    read -n 1 -s -r -p 'Is it OK to delete ~/.ssh/config (y/n)? ' YN
    echo ""
    if [[ "$YN" != "y" ]]; then
        yell 'Must be able to replace ~/.ssh/config!'
    fi
    # need library hardcoded
    source "$HOME/.bash_library"
    # kill symlinks by default, send to all child processes
    local PRIMARYPROFILE="$1"
    local WORKINGPROFILE="$2"
    # create crypt-profiles automatically
    mkdir -p "$WORKINGPROFILE"
    # get rid of agents
    killall-agents
    # gpg symlinks
    [[ -e "$HOME/.gnupg" ]] && \mv --backup=t -- "$HOME/.gnupg" "$HOME/.gnupg.backup"
    # make sure things are synced
    cp_if_different "$PRIMARYPROFILE/pubring.gpg"        "$WORKINGPROFILE/pubring.gpg"
    cp_if_different "$PRIMARYPROFILE/secring.gpg"        "$WORKINGPROFILE/secring.gpg"
    cp_if_different "$PRIMARYPROFILE/trustdb.gpg"        "$WORKINGPROFILE/trustdb.gpg"
    # TODO: working profile must exist...
    mkdir -p "$WORKINGPROFILE/private-keys-v1.d"
    # TODO: cp_if_different wildcards?
    cp "$PRIMARYPROFILE/private-keys-v1.d"/* "$WORKINGPROFILE/private-keys-v1.d"
    need_new_symlink "$WORKINGPROFILE" "$HOME/.gnupg"
    # link to the secrets files
    need_new_directory "$HOME/.secrets"
    # a loop to copy
    for THESECRETFILE in $PRIMARYPROFILE/*; do
        [[ $THESECRETFILE =~ secrets || $THESECRETFILE =~ openvpn ]]  || continue
        local THEBASENAME=$(basename -- "$THESECRETFILE")
        cp_if_different "$THESECRETFILE" "$HOME/.secrets/$THEBASENAME"
    done
    # secrets files
    local THEBASENAME=$(basename -- "${PRIMARYPROFILE##*-}")
    cp_if_different "$PRIMARYPROFILE/secrets.txt.gpg"     "$HOME/.secrets/$THEBASENAME.txt.gpg"
    cp_if_different "$PRIMARYPROFILE/id_rsa.txt.gpg"      "$HOME/.secrets/id_rsa.txt.gpg"
    cp_if_different "$PRIMARYPROFILE/id_ecdsa.txt.gpg"    "$HOME/.secrets/id_ecdsa.txt.gpg"
    cp_if_different "$PRIMARYPROFILE/id_ed25519.txt.gpg"  "$HOME/.secrets/id_ed25519.txt.gpg"
    # ssh files
    cp_if_different "$PRIMARYPROFILE/id_ecdsa"            "$HOME/.ssh/id_ecdsa"
    cp_if_different "$PRIMARYPROFILE/id_ecdsa.pub"        "$HOME/.ssh/id_ecdsa.pub"
    cp_if_different "$PRIMARYPROFILE/id_ed25519"          "$HOME/.ssh/id_ed25519"
    cp_if_different "$PRIMARYPROFILE/id_ed25519.pub"      "$HOME/.ssh/id_ed25519.pub"
    cp_if_different "$PRIMARYPROFILE/id_rsa"              "$HOME/.ssh/id_rsa"
    cp_if_different "$PRIMARYPROFILE/id_rsa.pub"          "$HOME/.ssh/id_rsa.pub"
    cp_if_different "$CRYPTSSHCONFIGPATH/config" "$HOME/.ssh/config"
    # for scripts that modify .ssh/config, ensure there always an original
    cp_if_different "$CRYPTSSHCONFIGPATH/config"          "$HOME/.ssh/config_fallback"
    # copy gpg config files
    cp_if_different  "$CRYPTGPGCONFIGPATH/gpg.conf"       "$HOME/.gnupg/gpg.conf"
    cp_if_different  "$CRYPTGPGCONFIGPATH/gpg-agent.conf" "$HOME/.gnupg/gpg-agent.conf"
    fix-gpg-ssh-permissions
}

# TODO: actually do this
crypt-profile-backup () {
    false
}

# TODO: this is non-functional
crypt-profile-printable () {
    # TODO: need actual "$1" argument and to sort out whether master,primary,working
    # TODO: not $KEYSLOCATION variable
    # create a printable version of the profile, only print appropriate things
    local KEYSLOCATION="$1"
    if [[ -f "$KEYSLOCATION"/pubring.gpg ]]; then
        local NAMES=()
        # get all gpg public keys ids
        while read LINE; do
            local REGEX='uid[[:space:]](.*)'
            [[ "$LINE" =~ $REGEX ]] && NAMES+=( "${BASH_REMATCH[1]}" )
        done < <(gpg --list-keys --keyid-format 0xlong --no-default-keyring --keyring "$KEYSLOCATION/pubring.gpg")
        # now get name and fingerprint for all keyids
        for NAME in ${NAMES[@]}; do
            # echo "here"
            # echo "$NAME"
            # gpg --list-keys --fingerprint --keyid-format 0xlong --no-default-keyring --keyring "$KEYSLOCATION/pubring.gpg" "$NAME"
            # echo "there"
            local STRIPNAME=$(sed -e 's/^ *//g' -e 's/ *$//g' <<< "$NAME")
            local KEYIDS=()
            while read LINE; do
                local REGEXID='0x([0-9A-Z]{16})'
                local REGEXFINGER='Key fingerprint = (.*)'
                if [[ "$LINE" =~ $REGEXID ]]; then
                    KEYIDS+=( "${BASH_REMATCH[1]}" )
                elif [[ "$LINE" =~ $REGEXFINGER ]]; then
                    # TODO: does this line always run?
                    local KEYFINGERPRINT="${BASH_REMATCH[1]}"
                fi
            done < <(gpg --list-keys --fingerprint --keyid-format 0xlong --no-default-keyring --keyring "$KEYSLOCATION/pubring.gpg" "$NAME")
            # get the ascii representation of the key
            for KEYID in ${KEYIDS[@]}; do
                # output printable versions of the keys
                # TODO any reason to output just fingerprints... useful without public key?
                echo -n "" > "$KEYSLOCATION/$STRIPNAME--$KEYID--public.txt"
                echo -n "" > "$KEYSLOCATION/$STRIPNAME--$KEYID--private.txt"
                echo "$NAME" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--public.txt"
                echo "$NAME" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--private.txt"
                echo "" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--public.txt"
                echo "" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--private.txt"
                echo "$KEYID" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--public.txt"
                echo "$KEYID" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--private.txt"
                echo "" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--public.txt"
                echo "" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--private.txt"
                echo "$KEYFINGERPRINT" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--public.txt"
                echo "$KEYFINGERPRINT" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--private.txt"
                echo "" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--public.txt"
                echo "" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--private.txt"
                gpg2 --export -a "$KEYID" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--public.txt"
                gpg2 --export-secret-keys -a "$KEYID" >> "$KEYSLOCATION/$STRIPNAME--$KEYID--private.txt"
            done

            # echo "$NAME"
            # echo "${KEYIDS[@]}"
            # echo "${KEYFINGERPRINTS[@]}"
            # echo "$KEYASCII"
            # echo "$PRIVATEASCII"
            # echo "================================================================================"
        done
    fi
}

killall-agents () {
    # kill all the agents and remove identifying information
    # XXXX: this is an incredibly crude way to reset, but works when nothing else does
    pkill -9 --full gpg-agent
    pkill -9 --full ssh-agent
    # XXXX: not completely desirable, but kill gnome keychain because it often interferes
    pkill -9 --full gnome-keyring-daemon
    # this is hopefully enough to purge it
    # TODO: delete only things I own?
    # find /tmp -iname "gpg-*" &>/dev/null && \rm /tmp/gpg-*
    [[ -e "$HOME/.keychain" ]] && find "$HOME/.keychain" -type f -delete
}

harm-crypt () {
    # harm stands for harmonize and is a nice prefix I use
    # XXXX: this function is pretty brutal, but resets very well
    killall-agents
    source "$HOME/.bash_profile"
    # TODO: decide if I really want this here like this, maybe use function?
    # if ps -ef | grep --color=never -- "emacs --daemon" | grep -v grep >/dev/null && type -P launch-emacsclient >/dev/null 2>&1; then
    #     h2 "Re-initing Emacs!"
    #     launch-emacsclient noframe --eval "(cic:init-crypt)"
    # fi
}

ssh-keygen-ed25519 () {
    # generate an ssh key in the current directory based on username and host

    # $1=full path to put the key in, current path if not specified
    # $2=password to use for key, will ask if not specified
    if [[ -z "$1" ]]; then
        local KEYPATH=./id_ed25519
    else
        local KEYPATH="$1"/id_ed25519
    fi
    if [[ -z "$2" ]]; then
        ssh-keygen -b 521 -t ed25519 -C "$(id -un)@$HOSTNAME-$(date --rfc-3339=date)" -f "$KEYPATH"
    else
        local PASSWORD="$2"
        ssh-keygen -b 521 -t ed25519 -C "$(id -un)@$HOSTNAME-$(date --rfc-3339=date)" -P "$PASSWORD" -f "$KEYPATH"
    fi
}

ssh-keygen-rsa () {
    # generate an ssh key using RSA in the current directory based on username and host
    # XXXX: often used on older hosts or for things like github

    # $1=full path to put the key in, current path if not specified
    # $2=password to use for key, will ask if not specified
    if [[ -z "$1" ]]; then
        local KEYPATH=./id_rsa
    else
        local KEYPATH="$1"/id_rsa
    fi
    if [[ -z "$2" ]]; then
        ssh-keygen -b 4096 -t rsa -C "$(id -un)@$HOSTNAME-$(date --rfc-3339=date)" -f "$KEYPATH"
    else
        local PASSWORD="$2"
        ssh-keygen -b 4096 -t rsa -C "$(id -un)@$HOSTNAME-$(date --rfc-3339=date)" -P "$PASSWORD" -f "$KEYPATH"
    fi
}

################################################################################
# temporary functions to create temporary keys for situtations of low
# security risk (initial install over a LAN)

# TOOD: test before documenting

bootstrap-temporary-ssh () {
    if [[ -z "$1" ]]; then
        yell "No host specified!"
        return 1
    fi
    # XXXX: only do this if an id_rsa does not already exist on host machine
    # create a temporary ssh key without a password, based on
    ssh-keygen -b 4096 -t rsa -C "Temporary key to login to $HOSTNAME-$(date --rfc-3339=date)" -f "$HOME/.ssh/id_rsa_temp"
    # copy private key to the host machine
    ssh $(whoami)@"$1" mkdir -p "$HOME/.ssh"
    scp "$HOME/.ssh/id_rsa_temp" $(whoami)@"$1:$HOME/.ssh/id_rsa"
    scp "$HOME/.ssh/id_rsa_temp.pub" $(whoami)@"$1:$HOME/.ssh/id_rsa.pub"
    chmod 600 "$HOME/.ssh/id_rsa_temp*"
    # copy to authorized keys
    cat "$HOME/.ssh/id_rsa_temp.pub" >> "$HOME/.ssh/authorized_keys"
}

bootstrap-temporary-ssh-remove () {
    # delete specific one on specific host?
    # TODO: I should ask nicely before I do this
    # TODO: give some options for hosts?
    if [[ -z "$1" ]]; then
        yell "No host specified!"
        return 1
    fi
    # XXXX: only do this if an id_rsa does not already exist on host machine
    # delete on private key on host machine
    ssh $(whoami)@"$1" \rm "$HOME/.ssh/id_rsa"
    # delete public and authorized keys on this machine
    # TODO: clean up blank lines
    sed -i '/Temporary key to login/d' "$HOME/.ssh/authorized_keys"
    # delete the keys themselves
    \rm "$HOME/.ssh/id_rsa_temp" "$HOME/.ssh/id_rsa_temp.pub"
}

bootstrap-temporary-ssh-remove-all () {
    # delete public and authorized keys on this machine
    # fix up authorized keys
    # TODO: I should ask nicely before I do this
    # TODO: do I want to clear up authorized keys elsewhere
    sed -i '/Temporary key to login/d' "$HOME/.ssh/authorized_keys"
    # delete the keys themselves
    sed -i '/^\s*$/d' "$HOME/.ssh/authorized_keys"
    home-trash "$HOME/.ssh/id_rsa_temp"
    home-trash "$HOME/.ssh/id_rsa_temp.pub"
}

bootstrap-nuke-crypt-home () {
    # deletes (backs up?) any stuff hanging around
    home-trash "$HOME/.ssh/config"
}

################################################################################
# encrypt and decrypt files

encrypt-file () {
    # encrypt a file using gpg, checks with user to ensure there are no errors before deleting original
    #
    # $1=file to encrypt
    # TODO: should this be moved to bashrc_functions_crypt_external?
    if [[ ! -e "$1" ]]; then
        yell "Must specify an actual file to encrypt!!!"
        return 1
    fi
    local NEWNAME=$(generate-uid)
    tar -cvzf - "$1" | gpg2 --recipient "$CRYPTGPGUSER" --output "$NEWNAME".tgz.gpg --encrypt -
    msg "Exit status: $? || Pipe status: ${PIPESTATUS[*]}"
    # TODO: is this a good way of verifying shredded file?
    verify-operation "Encrypt OK? do you wish to delete the original? (y/n) " "Really keep original? (y/n) " "$1"
}

encrypt-file-password () {
    # encrypt a file with a password (to be put through
    # another channel) get the psk in plain text
    #
    # generally to transfer secret keys, things needed to bootstrap a
    # secret system, or other information once; after which the paper
    # is completely destroyed
    #
    # this methodlogy is used because one can take precautions to be
    # relatively confident that any comprimise of paper would be
    # suspected
    local TOPSECRET=$(super-password-easy)
    msg "Password is: $TOPSECRET"
    while read -r -t 0;do read -r; done
    read -n 1 -s -r -p "Please write down the password and press any key to continue... "
    export TRYAGAIN=
    while [[ $TRYAGAIN != "y" ]]; do
        clear
        # TODO: not sure if I should really do this twice
        while read -r -t 0;do read -r; done
        read -e -p "Re-enter password: " TOPSECRET1
        if [[ $TOPSECRET != $TOPSECRET1 ]]; then
            # TODO: try again
            warn "Password does not match!!! Write down again!!!"
            warn "Password is: $TOPSECRET"
            while read -r -t 0;do read -r; done
            read -n 1 -s -r -p "Press any key to continue... "
            local TRYAGAIN="n"
            continue
        fi
        local TRYAGAIN=y
    done
    msg "Passwords recorded successfully!"
    local FILEUID=$(generate-uid)
    msg "The file UID is: $FILEUID"
    tar -cvzf - "$1" | gpg2 --cipher-algo AES256 --passphrase "$TOPSECRET" --output "$FILEUID".tgz.gpg --symmetric -
    msg "Encryption finished!!! "
}

decrypt-file () {
    # decrypt a file encrypted using gpg into a temporary path and then move to the current path
    # uses the backup feature of mv to ensure files are never clobbered and operation is verified
    # by the user before deleting the original file
    #
    # $1=path of file to decrypt
    h1
    if [[ ! -e "$1" ]]; then
        yell "$1 is not a real file to decrypt!!!"
        return 1
    fi
    # create random tmp directory here
    local TMPPATH=$(mktemp -d -p .)
    msg "Decrypting $1 into $TMPPATH"
    # XXXX: assuming successful
    gpg-batch --decrypt "$1" | tar -xvzf - --directory "$TMPPATH"
    msg "Exit status: $? || Pipe status: ${PIPESTATUS[*]}"
    \mv --backup=t -- "$TMPPATH/"* .
    # TODO: want to fail completely if not able to remove?
    rmdir "$TMPPATH"
    verify-operation "Decrypt OK? Do you wish to delete the encrypted file? (y/n) " "Really keep encrypted? (y/n) " "$1"
}

decrypt-file-password () {
    h1
    if [[ ! -e "$1" ]]; then
        yell "$1 is not a real file to decrypt!!!"
        return 1
    fi
    local TMPPATH=$(mktemp -d -p .)
    msg "Decrypting $1 into $TMPPATH"
    gpg-batch --decrypt "$1" | tar -xvzf - --directory "$TMPPATH"
    msg "Exit status: $? || Pipe status: ${PIPESTATUS[*]}"
    \mv --backup=t -- "$TMPPATH"/* .
    # TODO: want to fail completely if not able to remove?
    rmdir "$TMPPATH"
}

decrypt-flatten () {
    # go over all files in a directory and decrypt them into the current directory
    # TODO: this function in particular should also mv everything from subdirectories into current directory
    for fname in $PWD/*; do
        if [[ "$fname" =~ tgz.gpg$ ]]; then
            # decrypt file and delete (or trash)
            decrypt-file "$fname"
        fi
    done
}

################################################################################
# containers

mount-container () {
    # mount an encrypted luks container on an appropiate mount point
    #
    local USAGE="Usage: mount-container <<luks container path>> <<mount point>>

  <<luks container path>> the path to the luks container, the filename
    of the container is the same name used for the mapping in /dev/mapper

  <<mount point>> mount point to create and use"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE" 1>&2
        return 1
    fi
    # TODO: condense logic
    if [[ -e "$2" || -h "$2" ]]; then
        if [[ -h "$2" && ! -e "$2" ]]; then
            \rm "$2"
        elif [[ -d "$2" ]]; then
            # TODO: try to rmdir
            rmdir "$2"
        else
            yell "$2 exists and is not a broken symlink or empty directory! Remove manually!"
            return 1
        fi
    fi
    local THEBASENAME=$(basename -- "$1")
    if [[ ! -e "/dev/mapper/$THEBASENAME" ]]; then
        msg "Opening $THEBASENAME!"
        sudo cryptsetup luksOpen "$1" "$THEBASENAME"
    else
        warn "Container $THEBASENAME is already mapped!"
        true
    fi
    # TODO: add more error checking?
    if [[ $? != 4 ]]; then
        local MNTBASENAME=$(basename -- "$2")
        echo "Creating directory: /run/user/$(id -u)/$MNTBASENAME" 1>&2
        mkdir -p /run/user/$(id -u)/"$MNTBASENAME"
        echo "Creating symlink: /run/user/$(id -u)/$MNTBASENAME --> $2" 1>&2
        ln -s /run/user/$(id -u)/"$MNTBASENAME" "$2"
        # if mount unsuccessful
        # TODO: unmap crypt and maybe checking command directly is good
        if [[ "$?" != 0 ]]; then
            yell "Error creating symlink for mounting container!"
            return 1
        fi
        # TODO: do better than this
        if ! mountpoint -q /run/user/$(id -u)/"$MNTBASENAME"; then
            sudo mount "/dev/mapper/$THEBASENAME" /run/user/$(id -u)/"$MNTBASENAME"
            # fuse2fs "/dev/mapper/$THEBASENAME" "$2"
            # TODO: severe, do not do this
            # sudo chown -R "$USER:$USER" "$2"
        else
            warn "Mount point $2 already mounted!"
        fi
    else
        yell "Cannot find specified container"
    fi
}

umount-container () {
    # unmount an encrypted luks container by using exactly the same
    # arguments as mount-container
    #
    # $1=the path to the luks container, the filename of the container
    #    is the same name used for the mapping in /dev/mapper
    # $2=mount point, deleted after unmounting
    local USAGE="Usage: umount-container <<luks container path or mount point>>

  <<luks container path or mount point>> the path to the luks
    container, the filename of the container is the same name used for
    the mapping in /dev/mapper, or the mount point to umount and remove"
    if [[ -z "$1" ]]; then
        echo "$USAGE" 1>&2
        return 1
    fi
    if [[ -d "$1" ]]; then
        if mountpoint -q "$1"; then
            local MOUNTPOINT=$(readlink -f -- "$1")
            local MAPPER=$(findmnt -nr -o source "$MOUNTPOINT")
        else
            yell "Nothing mounted at $1!"
            return 1
        fi
    else
        if [[ -b "$1" ]];then
            local MAPPER="$1"
            local MOUNTPOINT=$(findmnt -nr -o target "$MAPPER")
        elif [[ -b "/dev/mapper/$1" ]];then
            local MAPPER="/dev/mapper/$1"
            local MOUNTPOINT=$(findmnt -nr -o target "$MAPPER")
        else
            warn "No device found correpsonding to $1!"
            return 1
        fi
    fi
    # sudo true || { echo 'Failed to sudo!' 1>&2; return 1; }
    msg "Unmounting $MOUNTPOINT!"
    sudo umount "$MOUNTPOINT"
    # fusermount -u "$MOUNTPOINT"
    # TODO: get rid of directory anyways?
    rmdir "$MOUNTPOINT"
    [[ -h "$1" ]] && \rm "$1"
    msg "Closing $MAPPER!"
    sudo cryptsetup luksClose "$MAPPER"
}

open-vg () {
    # open a LVM volume group from an encrypted luks container
    local USAGE="Usage: open-vg <<luks container path>> <<volume group>>

  <<luks container path>> the path to the luks container, the filename of the container
    is the same name used for the mapping in /dev/mapper

  <<volume group>> the name of the volume group"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE" 1>&2
        return 1
    fi
    if [[ -e "$1" ]]; then
        local THEBASENAME=$(basename -- "$1")
        if [[ ! -e "/dev/mapper/$THEBASENAME" ]]; then
            msg "Opening $THEBASENAME!"
            sudo cryptsetup luksOpen "$1" "$THEBASENAME"
        else
            warn "Device /dev/mapper/$THEBASENAME already mapped!"
        fi
        # TODO: should I still activate volumes anyways, even if already mapped?
        sudo vgchange -a y "$2"
    else
        warn "Image $1 not found!"
    fi
}

open-vg-maintenance () {
    # open a LVM volume group from an encrypted luks container
    # TODO: combine code?
    local USAGE="Usage: open-vg-maintenance <<luks container path>> <<volume group>>

  <<luks container path>> the path to the luks container, the filename of the container
    is the same name used for the mapping in /dev/mapper

  <<volume group>> the name of the volume group"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE" 1>&2
        return 1
    fi
    if [[ -e "$1" ]]; then
        local THEBASENAME=$(basename -- "$1")
        if [[ ! -e "/dev/mapper/$THEBASENAME" ]]; then
            msg "Opening $THEBASENAME!"
            sudo cryptsetup luksOpen "$1" "$THEBASENAME"
        else
            warn "Device /dev/mapper/$THEBASENAME already mapped!"
        fi
        # TODO: warn if already mapped
    else
        warn "Image $1 not found!"
    fi
}

vg-container-expand () {
    # https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_a_non-root_file_system#Resizing_the_loopback_filesystem
    # XXXX: highly recommend having a backup here and not rerunning if it fails!
    # XXXX: not thoroughly tested!!!!
    # TODO: would like to enter password once at beginning
    # TODO: want better error checking ahead of time
    local USAGE="Usage: vg-container-expand <<luks container path>> <<size to add>>

  <<luks container path>> the path to the luks container, the filename of the container
    is the same name used for the mapping in /dev/mapper

  <<size to add>> the number of gb to add"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE" 1>&2
        return 1
    fi
    if ask_yn "This is a dangerous and poorly tested function!!! Continue";then
        local CONTAINER="$1"
        local SIZEADD="$2"
        if [[ -e "$CONTAINER" ]]; then
            # expand the container file itself, this is irreversible
            # TODO: 80G takes about ??? use my better functions that use openssl
            # dd if=/dev/urandom bs=1M count="$SIZEADD" | cat - >> "$CONTAINER"
            write-random-data-stdout "$SIZEADD" | cat - >> "$CONTAINER"
            # mount the encrypted container to resize (does this have to happen on loopback)
            local THEBASENAME=$(basename -- "$CONTAINER")
            sudo cryptsetup luksOpen "$CONTAINER" ""
            sudo cryptsetup resize "$THEBASENAME"
            # expand the physical volume
            sudo /sbin/pvresize "/dev/mapper/$THEBASENAME"
            # finally close everything down
            # TODO: not quite working yet, how do I know archive name to close it down properly?
            #       do I even need to do this
            sudo vgchange -a n "/dev/mapper/$THEBASENAME"
            sudo cryptsetup luksClose "$THEBASENAME"
        else
            yell "Container does not exist!!!"
        fi
    fi
}

close-vg () {
    # close a LVM volume group from an encrypted luks container
    # uses the same set of arguments as open-vg
    local USAGE="Usage: close-vg <<luks container path>> <<volume group>>

  <<luks container path>> the pathcase
 to the luks container, the filename of the container
    is the same name used for the mapping in /dev/mapper

  <<volume group>> the name of the volume group"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE" 1>&2
        return 1
    fi
    local THEBASENAME=$(basename -- "$1")
    if [[ -e "/dev/mapper/$THEBASENAME" ]]; then
        sudo vgchange -a n "$2"
        msg "Closing $THEBASENAME!"
        sudo cryptsetup luksClose "$THEBASENAME"
    else
        warn "Device $1 does not exist!"
    fi
}

mount-vg-img () {
    # mount an encrypted luks container from an encrypted luks LVM image
    local USAGE="Usage: mount-vg-img <<volume group>> <<mount point>>

  <<volume group>> name of the volume group

  <<mount point>>  mount point to create and use"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE" 1>&2
        return 1
    fi
    local THEBASENAME=$(basename -- "$2")
    if [[ -e "/dev/mapper/$1" ]]; then
        msg "Opening $THEBASENAME!"
        sudo cryptsetup luksOpen "/dev/mapper/$1" "$THEBASENAME"
    else
        warn "Device /dev/mapper/$1 already mapped!"
    fi
    if ! mountpoint -q "$2"; then
        mkdir -p "$2"
        sudo mount "/dev/mapper/$THEBASENAME" "$2"
        sudo chown -R "$USER:$USER" "$2"
    else
        warn "Device /dev/mapper/$1 already mounted!"
    fi
}

umount-vg-img () {
    # unmount an encrypted luks container from an encrypted luks LVM
    # image by using exactly the same arguments as mount-vg-img
    local USAGE="Usage: umount-vg-img <<volume group>> <<mount point>>

  <<volume group>> name of the volume group

  <<mount point>>  mount point that is deleted after unmounting"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE" 1>&2
        return 1
    fi
    if [[ -d "$2" ]]; then
        # TODO: seperate function?
        if mountpoint -q "$2"; then
            msg "Unmounting $2!"
            sudo umount "$2"
        else
            warn "Nothing mounted!"
        fi
        # XXXX: get rid of directory anyways
        rmdir "$2"
    fi
    local THEBASENAME=$(basename -- "$2")
    if [[ -e "/dev/mapper/$THEBASENAME" ]]; then
        msg "Closing $THEBASENAME!"
        sudo cryptsetup luksClose "$THEBASENAME"
    else
        warn "Container $THEBASENAME not mapped!"
    fi
}

################################################################################
# system maintenance functions

kill-recent-files-line () {
    # XXXX: dangerous functions for convenience in batch mode
    # TODO: want to make this more general
    [[ -f "$1" ]] && sed -i '/\[Recent Files\]/,/^\s*$/{d}' "$1"
}

export-firefox-bookmarks () {
    # http://www.commandlinefu.com/commands/view/14088/get-your-firefox-bookmarks
    # XXXX: used before deleting places.sqlite, because that's a cool thing to do, and put any bookmarks in text file
    # TODO: do similarily terrible things elsewhere
    # TODO: test if there is an sqllite
    sqlite3 ~/.mozilla/firefox/*.[dD]efault/places.sqlite "SELECT strftime('%d.%m.%Y %H:%M:%S', dateAdded/1000000, 'unixepoch', 'localtime'),url FROM moz_places, moz_bookmarks WHERE moz_places.id = moz_bookmarks.fk ORDER BY dateAdded;"
}

privacy-brief () {
    # XXXX: suppress automatic privacy clearing if needed
    if [[ -e "$HOME/inhibit-privacy" ]]; then
        yell "Privacy cleanup suppressed!!!"
    else
        # delete benign things, that shouldn't cause too much trouble
        # XXXX: seems to cause issues with long downloads in firefox
        # TODO: are things running that I don't want to clear privacy for
        # TODO: add things like vlc to test, or check if anything is currently using places to be shred
        if ! ps -ef | grep --color=never '[f]irefox\|[i]ceweasel\|[p]alemoon\|[w]aterfox' >/dev/null; then
            privacy-full --batch
            echo "$(date-time-stamp) Success" >> "$HOME/.myprivacy.log"
        else
            warn "Programs running! Will do privacy-brief later!"
            echo "$(date-time-stamp) Delayed" >> "$HOME/.myprivacy.log"
        fi
    fi
}

# privacy-all () {
#     # XXXX: requires crypt-profiles to be in path
#     sudo env "PATH=$PATH" privacy-all.sh "$USER"
# }

privacy-trash () {
    h2 "Clearing trash"
    # TODO: why am I checking this like this?
    if [[ -d "$HOME/tmp/trash/" ]] && find "$HOME/tmp/trash/" -mindepth 1 -print -quit 2>/dev/null | grep --color=never -q .; then
        msg  "Contents of ~/tmp/trash:"
        \ls -A "$HOME"/tmp/trash/*
        while read -r -t 0;do read -r; done
        # TODO: add a countdown here
        if ask_yn "Do you want to delete ~/tmp/trash?";then
            local CLEARTMPTRASH=1
        else
            local CLEARTMPTRASH=
        fi
    else
        warn "Nothing in ~/tmp/trash"
    fi
    if [[ -d "$HOME/tmp/screenshots-collect/" ]] && find "$HOME/tmp/screenshots-collect/" -mindepth 1 -print -quit 2>/dev/null | grep --color=never -q .; then
        msg  "Contents of ~/tmp/screenshots-collect:"
        \ls -A "$HOME"/tmp/screenshots-collect/*
        while read -r -t 0;do read -r; done
        # TODO: add a countdown here
        if ask_yn "Do you want to delete ~/tmp/screenshots-collect?";then
            local CLEARSCREENSHOTS=1
        else
            local CLEARSCREENSHOTS=
        fi
    else
        warn "Nothing in ~/tmp/screenshots-collect"
    fi
    if [[ -d "$HOME/.local/share/Trash/files/" ]] && find "$HOME/.local/share/Trash/files/" -mindepth 1 -print -quit 2>/dev/null | grep --color=never -q .; then
        msg "Contents of ~/.local/share/Trash/files/:"
        \ls -A "$HOME/.local/share/Trash/files/"
        # TODO: check if empty?
        if ask_yn "Do you want to delete ~/.local/share/Trash/?"; then
            local CLEARLOCALTRASH=1
        else
            local CLEARLOCALTRASH=
        fi
    else
        warn "Nothing in $HOME/.local/share/Trash/files/"
    fi
    if [[ -z "$1" ]]; then
        if [[ -d "$HOME/tmp/tmp-shred/" ]] && find "$HOME/tmp/tmp-shred/" -mindepth 1 -print -quit 2>/dev/null | grep --color=never -q .; then
            msg "Contents of ~/tmp/tmp-shred/:"
            \ls -A "$HOME/tmp/tmp-shred/"
            # TODO: check if empty?
            if [[ -n "$1" ]] || ask_yn "Do you want to delete ~/tmp/tmp-shred/?"; then
                local CLEARTMPSHRED=1
            else
                local CLEARTMPSHRED=
            fi
        fi
    else
        local CLEARTMPSHRED=1
    fi
    if [[ -n "$CLEARTMPTRASH" ]]; then
        kill-directory-contents "$HOME/tmp/trash"
    fi
    if [[ -n "$CLEARSCREENSHOTS" ]]; then
        kill-directory-contents "$HOME/tmp/screenshots-collect"
    fi
    if [[ -n "$CLEARLOCALTRASH" ]]; then
        kill-recursive "$HOME/.local/share/Trash/"
    fi
    # always shred tmp-shred if called automatically
    privacy-tmp-shred "$CLEARTMPSHRED"
}

privacy-tmp-shred () {
    # TODO: make interactive
    if [[ -d "$HOME/tmp/tmp-shred/" ]] && find "$HOME/tmp/tmp-shred/" -mindepth 1 -print -quit 2>/dev/null | grep --color=never -q .; then
        msg "Contents of ~/tmp/tmp-shred/:"
        \ls -A "$HOME/tmp/tmp-shred/"
        # TODO: check if empty?
        if [[ -n "$1" ]] || ask_yn "Do you want to delete ~/tmp/tmp-shred/?"; then
            kill-recursive "$HOME/tmp/tmp-shred/"
        fi
    fi
    need_new_directory "$HOME/tmp/tmp-shred/"
    # temporary place for imagemagick
    privacy-tmp-shred-try "$HOME/tmp/tmp-imagemagick/"
    privacy-tmp-shred-try "$HOME/mnt-secondary/tmp/tmp-imagemagick/"
    # temproary place to process documents
    privacy-tmp-shred-try "$HOME/tmp/tmp-document-process-/"
    privacy-tmp-shred-try "$HOME/mnt-secondary/tmp/tmp-document-process/"
    # temporary place to store previews
    privacy-tmp-shred-try "$HOME/tmp/tmp-cic-preview/"
    privacy-tmp-shred-try "$HOME/mnt-secondary/tmp/tmp-cic-preview/"
    # a temporary place to create archives
    privacy-tmp-shred-try "$HOME/tmp/tmp-archive-process/"
    privacy-tmp-shred-try "$HOME/mnt-secondary/tmp/tmp-archive-process/"
    # a temporary place to unencrypt
    privacy-tmp-shred-try "$HOME/tmp/tmp-gpg/"
    privacy-tmp-shred-try "$HOME/mnt-secondary/tmp/tmp-gpg/"
    # a temporary place to mount compressed webpages
    privacy-tmp-shred-try "$HOME/tmp/tmp-webz/"
    privacy-tmp-shred-try "$HOME/mnt-secondary/tmp/tmp-webz/"
}

privacy-tmp-shred-try () {
    if [[ -d "$1" ]] && find "$1" -mindepth 1 -print -quit 2>/dev/null | grep --color=never -q .; then
        kill-recursive "$1"
        need_new_directory "$1"
    fi
}

privacy-conkeror () {
    h2 "Conkeror"
    # XXXX: I now use a password manager and just clear everything
    if ! check-mozilla-running; then
        if [[ -n "$CONKERORTEMPLATEPATH" && -d "$CONKERORTEMPLATEPATH" ]]; then
            for PROFILEDIR in $HOME/.conkeror.mozdev.org/conkeror/*; do
                [[ -d "$PROFILEDIR" ]] || continue
                echo "$PROFILEDIR" 1>&2
                local PROFILEBASENAME=$(basename -- "$PROFILEDIR")
                # PROFILEDIR=$(find "$HOME/.conkeror.mozdev.org/conkeror/" -mindepth 1 -maxdepth 1 -type d -iname "*.default")
                # if [[ $(wc -l <<< "$PROFILEDIR") == "1" && -d "$PROFILEDIR" ]]; then
                SHREDDIR="$HOME/tmp/tmp-shred/$(date-time-stamp)-conkeror-profile-$PROFILEBASENAME"
                need_new_directory "$SHREDDIR"
                mv "$PROFILEDIR" "$SHREDDIR"
                echo "Trashed old profile at $PROFILEDIR if it existed!" 1>&2
                mkdir -p "$PROFILEDIR"
                cp -r "$CONKERORTEMPLATEPATH"/* "$PROFILEDIR"
                echo "Copied a new profile as $PROFILEDIR!" 1>&2
                # else
                #     echo "Old conkeror profile not found so nothing trashed!" 1>&2
                # fi
                # cache files
                # TODO: copy to tmp
                kill-directory-contents "$HOME/.cache/conkeror.mozdev.org/"
            done
        elif [[ -d "$HOME/.conkeror.mozdev.org/" ]]; then
            msg "Clearing firefox-based browsers OK!"
            # XXXX: preserve as much as possible, like adblocker
            # TODO: keep shredding more
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" content-prefs.sqlite
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" cookies.sqlite
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" cookies.sqlite-shm
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" cookies.sqlite-wal
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" datareporting
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" downloads.json
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" formhistory.sqlite
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" mimeTypes.rdf
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" permissions.sqlite
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" places.sqlite
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" places.sqlite-shm
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" places.sqlite-wal
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" prefs.js
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" sessionCheckpoints.json
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" saved-telemetry-pings
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" storage
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" webappsstore.sqlite
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" webappsstore.sqlite-shm
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" webappsstore.sqlite-wal
            kill-find-matching "$HOME/.conkeror.mozdev.org/conkeror" xulstore.json
            # cache files
            kill-directory-contents "$HOME/.cache/conkeror.mozdev.org/"
            # TODO: are these really what I want for conkeror, does conkeror ever write here?
        fi
    else
        warn "Firefox or similar program running!"
    fi
}

privacy-firefox () {
    h2 "Firefox"
    if ! check-mozilla-running; then
        local FIREFOXPATH_DEFAULT=$(find "$HOME/.mozilla/firefox" -mindepth 1 -maxdepth 1 -type d -iname "*.default")
        if [[ $(wc -l <<< "$FIREFOXPATH_DEFAULT") == "1" && -d "$FIREFOXPATH_DEFAULT" ]]; then
            echo "Found Firefox profile at: $FIREFOXPATH_DEFAULT" 1>&2
            mv-directory-contents-to-tmp-shred "$FIREFOXPATH_DEFAULT" 'firefox-profile'
            echo "Trashed old Firefox 'default' profile if it existed" 1>&2
        else
            echo "Old firefox 'default' profile not found so nothing trashed!" 1>&2
        fi
    fi
    mv-directory-contents-to-tmp-shred "$HOME/.mozilla/firefox/Pending Pings" 'firefox-pings'
    mv-directory-contents-to-tmp-shred "$HOME/.mozilla/firefox/Crash Reports" 'firefox-crash'
    mv-directory-contents-to-tmp-shred "$HOME/.cache/mozilla/"                'firefox-cache'
    # TODO: do I still want to ask?
    # if [[ "$ynfirefox" =~ y ]]; then
    #     # TODO: terrible way to do this
    #     # TODO: no more firefox bookmarks need to be saved
    #     # if export-firefox-bookmarks >/dev/null; then
    #     #     export-firefox-bookmarks >> ~/Downloads/firefox-bookmarks-$(date-time-stamp).txt
    #     # else
    #     #     warn "Cannot export Firefox bookmarks, places.sqlite probably does not exist!"
    #     # fi
    #     # XXXX: this kills all bookmarks
    #     kill-find-matching "$HOME/.mozilla/firefox places.sqlite"
    #     kill-recursive "$HOME/.mozilla/firefox/Crash Reports"
    # else
    #     warn "Firefox running or not clearing due to no input.!"
    # fi
}

privacy-chromium () {
    h2 "Chromium"
    # XXXX: I only use chromium as a secondary browser, shredding most things, but keeping adblock?
    if ! check-chromium; then
        # TODO: any more I want?
        mv-directory-contents-to-tmp-shred "$HOME/.config/chromium/Default/"            'chromium-profile'
        mv-directory-contents-to-tmp-shred "$HOME/.config/chromium/Subresource Filter/" 'chromium-profile'
        mv-directory-contents-to-tmp-shred "$HOME/.config/chromium/ShaderCache/"        'chromium-profile'
        mv-directory-contents-to-tmp-shred "$HOME/.config/chromium/BrowserMetrics/"     'chromium-profile'
        mv-directory-contents-to-tmp-shred "$HOME/.cache/chromium/"                     'chromium-cache'
    else
        warn "Chromium running!"
    fi
    # chromium.form_history
}

privacy () {
    time {
        # TODO: things that ask first...
        # take out any leftover randomfiles used for filling hard drive with junk
        # this puts the sudo thing right at the from
        # TODO: also look for other locations
        # TODO: not sure I want this... causes issues when run nested...
        # [[ -e "$HOME/randomfile.bin" ]] && sudo \rm "$HOME/randomfile.bin"
        # TODO: reset so gnome does not give errors
        h1 "Clearing browser information"
        privacy-chromium
        privacy-firefox
        privacy-conkeror
        # TODO: any argument will do, not just --batch
        if [[ -z "$1" ]]; then
            h1 "Delete things that need user input"
            # while read -r -t 0;do read -r; done
            # # TODO: check if an sqllite exists before asking
            # read -n 1 -s -r -p "Do you want to delete all Firefox places.sqlite? (y/n) " ynfirefox
            # echo ""
            # this enables always shredding tmp-shred automatically
            if [[ -n "$1" ]] || ask_yn "Do you want to delete ~/tmp/tmp-shred/?"; then
                privacy-trash 1
                local DELETEDTMPSHRED=1
            else
                local DELETEDTMPSHRED=
            fi
            # XXXX: these are specific to other unreleased scripts I have
            h1 "Automatically deleting temporary files"
            for tmplocation in "$HOME"/tmp/*; do
                [[ -d "$tmplocation" ]] || continue
                # if [[ "$tmplocation" =~ flattened || "$tmplocation" =~ thumbnail ]]; then
                # TODO: do not delete thumbnail for now, decide later
                if [[ "$tmplocation" =~ flattened ]]; then
                    # do not allow .git directories to be mirrored then shredded, causes issues with shredding hardlinks
                    if [[ -z "$(find $tmplocation -iname \"*.git\" -type d)" ]]
                    then
                        msg "Killing $tmplocation"
                        kill-recursive "$tmplocation"
                    else
                        warn "The location $tmplocation appears to contain git repos!!!"
                    fi
                fi
            done
            local IMAGETMP="$HOME/tmp/image-tmp"
            if [[ -d  "$IMAGETMP" ]]; then
                if [[ -n "$(find $tmplocation -iname \"*.git\" -type d)" ]]; then
                    msg "Killing $IMAGETMP"
                    kill-recursive "$IMAGETMP"
                else
                    warn "The location $IMAGETMP appears to contain git repos!!!"
                fi

            fi
        else
            # clear $HOME/tmp/tmp-shred automatically, it is a good dumping ground for private files
            if [[ -n "$DELETEDTMPSHRED" ]]; then
                privacy-tmp-shred 1
            fi
        fi
        # privacy-palemoon
        h2 "Flash"
        # TODO: replace with something if flash is ever installed
        kill-directory-contents "$HOME/.abobe/Flash_Player"
        kill-directory-contents "$HOME/.macromedia/Flash_Player"
        # secondary browsers
        h2 "Google Chrome"
        kill-directory-contents "$HOME/.config/google-chrome"
        kill-directory-contents "$HOME/.cache/google-chrome"
        # TODO: fill this up, need elinks and w3m
        h2 "Links and other text-based browsers"
        kill-directory-contents "$HOME/.links2"
        kill-directory-contents "$HOME/.w3m"
        h2 "Recent application files"
        h2 "KDE"
        kill-directory-contents "$HOME"/.kde/share/apps/RecentDocuments/*
        # TODO: may never use this again
        kill-directory-contents "$HOME/.kde/share/apps/okular/docdata"
        kill-directory-contents "$HOME/.kde/share/apps/kconf_update/log"
        h2 "System-wide"
        kill-directory-contents "$HOME/.thumbnails"
        kill-directory-contents "$HOME/.cache/fontconfig"
        # TODO: want to kill "$HOME/.cache/event-sound-cache.*" "$HOME/.cache/qt_compose_cache_*" $HOME/.cache/gegl-"
        # destroy files that could leak privacy data
        # XXXX: this is a dangerous function that really nukes everything!!!
        # TODO: do I want umount-all type-function here?
        # clean out recently used lists
        h2 "Clearing recently used"
        kill-file "$HOME/.recently-used"
        kill-file "$HOME/.config/gxine/playlist"
        # causes problems on my system
        kill-file "$HOME/.config/mimeapps.list"
        kill-file "$HOME/.config/autostart/dropbox.desktop"
        kill-file "$HOME/.config/autostart/skypeforlinux.desktop"
        kill-recursive '$HOME/.local/share/*xbel*'
        kill-file-contents "$HOME/.local/share/user-places.xbel"
        kill-recent-files-line '/\[Recent Files\]/,/^\s*$/{d}' "$HOME/.kde/share/config/arkrc"
        kill-matching-line     '/Recent Urls/d'                "$HOME/.kde/share/config/dragonplayerrc"
        # kill-recent-files-line ~/.kde/share/config/gwenviewrc
        kill-recent-files-line "$HOME/.kde/share/config/katerc"
        kill-recent-files-line "$HOME/.kde/share/config/okularrc"
        # TODO: find out if these are really killed otherwise
        h2  "Clearing tracker/indexers"
        kill-directory-contents-preserve-structure "$HOME"/.local/share/tracker
        kill-directory-contents "$HOME"/.local/share/zeitgeist
        # https://unix.stackexchange.com/questions/192465/remove-paragraph-from-file
        # TODO: need a delete paragraph function
        # clear my personal trash
        # TODO: only kills dotfiles(dirs) if a normal file exists
        # only shred emacs files if interactive
        if [[ -z "$1" ]]; then
            # if ! check-emacs-daemon; then
            echo "Shredding temporary emacs files!" 1>&2
            kill-directory-contents "$HOME/.emacs.d/tmp/"
            kill-directory-contents "$HOME/.emacs.d/image-dired/"
            # TODO: ask before this?
            kill-directory-contents "$HOME/.local/share/zathura"
            kill-recursive  "$HOME/.local/share/data/qpdfview"
            kill-recursive "$HOME/.local/share/evolution"
            # TODO: possibly do less, so preserve vlc options
            # TODO: this kills some exensions I use
            # kill-directory-contents "$HOME/.local/share/vlc"
            kill-directory-contents "$HOME/.cache/vlc"
            kill-directory-contents "$HOME/.abobe"
            kill-directory-contents "$HOME/.cr3"
            # TODO: program I once tested, remove
            kill-directory-contents "$HOME/.viking"
            kill-directory-contents "$HOME/.xine"
            # TODO: if I seriously use this, fix
            kill-directory-contents "$HOME/.openshot"
            # TODO: if I seriously use this, fix
            kill-directory-contents "$HOME/.mypaint"
            kill-directory-contents "$HOME/.cache/matplotlib/"
            kill-directory-contents "$HOME/.cache/glances/"
            # TODO: "$HOME/.cache/openbox"
            # TODO: do I want this in batch mode or not
            #       can I just kill it and ones that look like it
            kill-file-contents "$HOME/.local/share/recently-used.xbel"
            # TODO: clear xsession... or just truncate like my other script????
            # kill-file-contents "$HOME"/.xsession-errors
        fi
        # clear $HOME/tmp/tmp-shred automatically, it is a good dumping ground for private files
        # this is done again at the end just in case it is used
        if [[ -n "$DELETEDTMPSHRED" ]]; then
            privacy-tmp-shred 1
        fi
        h2 "Re-caching programs such as Sage and Python"
        # rerun/recomple python and sage if they exist, to restore cached stuff
        # TODO: should this be done elsewhere? function for this
        if type -P sage &>/dev/null; then
            echo "recache sage" 1>&2
            time {
                sage -c "pass"
            }
        fi
        if type -P python &>/dev/null; then
            echo "recache python" 1>&2
            time {
                python -c "pass"
            }
        fi
        if type -P ipython &>/dev/null; then
            time {
                echo "recache ipython" 1>&2
                ipython -c "pass"
            }
        fi
    }
}

privacy-kill-freespace () {
    sudo true || { echo 'Failed to sudo!' 1>&2; return 1; }
    local CURRENTUSER="$USER"
    # TODO: is there a better way to do this, especially assuming we are in /root/
    sudo su root -c "su $CURRENTUSER -c 'source /home/$CURRENTUSER/.bash_library;privacy';source /root/.bashrc;kill-freespace-random-file /home/$CURRENTUSER"
}

################################################################################
# misc

fix-sshd-config () {
    # make /etc/sshd_config more secure
    # uses guidelines given by https://stribika.github.io/2015/01/04/secure-secure-shell.html
    # XXXX: I think I just have this avoid accidental running most of the time
    if [[ ! -e "./sshd_config" && ! -e "./bashrc_functions_crypt" ]]; then
        yell "Must be run in crypt-profiles path."
        return 1
    fi
    local TMPFILE=$(mktemp)
    # copy sshd_config to tmpfile
    cat /etc/ssh/sshd_config > "$TMPFILE"
    # edit my ssh block
    # delete my ssh block
    # TODO: deal with multiple copies
    sed -i '/#+BEGIN crypt_profiles ssd_config block/,/#+END crypt-profiles ssd_config block/d' "$TMPFILE"
    # comment out lines I will replace
    sed -e '/^Protocol/ s/^#*/# /'             -i "$TMPFILE"
    sed -e '/^HostKey/ s/^#*/# /'              -i "$TMPFILE"
    sed -e '/^Ciphers/ s/^#*/# /'              -i "$TMPFILE"
    sed -e '/^MACs/ s/^#*/# /'                 -i "$TMPFILE"
    sed -e '/^PermitRootLogin/ s/^#*/# /'      -i "$TMPFILE"
    sed -e '/^UseDNS/ s/^#*/# /'               -i "$TMPFILE"
    sed -e '/^GSSAPIAuthentication/ s/^#*/# /' -i "$TMPFILE"
    sed -e '/^LoginGraceTime/ s/^#*/# /'       -i "$TMPFILE"
    sed -e '/^AllowUsers/ s/^#*/# /'           -i "$TMPFILE"
    sed -e '/^Subsystem/ s/^#*/# /'            -i "$TMPFILE"
    sed -e '/^AllowTcpForwarding/ s/^#*/# /'   -i "$TMPFILE"
    # add my ssh block back
    bash -c "echo '' >> $TMPFILE"
    bash -c "cat ./sshd_config >> $TMPFILE"
    bash -c "echo '' >> $TMPFILE"
    # eliminate double lines
    sed -e '/^$/N;/^\n$/D'                     -i "$TMPFILE"
    # test
    if ! cmp --silent "$TMPFILE" /etc/ssh/sshd_config; then
        sudo cp --backup=t /etc/ssh/sshd_config /etc/ssh/sshd_config.bak
    fi
    sudo cp "$TMPFILE" /etc/ssh/sshd_config
    sudo service ssh restart
}

ssh-crypt-profile-batch-cmd () {
    # ssh into hostname without interaction by using secrets on current host
    # ssh-crypt-profile-batch-cmd <<hostname>> <<crypt-profile name>> <<command>>
    local PWDFILE="$HOME/.secrets/$2.txt.gpg"
    if [[ -f "$PWDFILE" ]]; then
        local TOPSECRET=$(DISPLAY= gpg-batch --no-tty --decrypt "$PWDFILE")
        if [[ $? == 0 ]]; then
            local GPGPWD=$(sed -n '1p' <<< "$TOPSECRET")
            local B64COMMAND=$(base64 <<< "$3")
            ssh-batch-interact $1 "source ~/.bash_profile $GPGPWD;source ~/.bash_library;bash -c \"$(base64 -d <<< ${B64COMMAND})\""
        else
            echo "Error decrypting!!!" 1>&2
        fi
    fi
}

crypt-luks-headers-dump () {
    sudo true || { echo 'Failed to sudo!' 1>&2; return 1; }
    (IFS=$'\n'
     for Z in $(lsblk -l -o name | tail -n +2); do
         if [[ -e /dev/"$Z" ]]; then
             local OUTPUT=$(sudo cryptsetup luksDump "/dev/$Z" 2>&1)
             if [[ $? == 0 ]]; then
                 h2 /dev/"$Z"
                 echo "$OUTPUT"
             fi
         elif [[ -e /dev/mapper/"$Z" ]]; then
             local OUTPUT=$(sudo cryptsetup luksDump "/dev/mapper/$Z" 2>&1)
             if [[ $? == 0 ]]; then
                 h2 /dev/mapper/"$Z"
                 echo "$OUTPUT"
             fi
         else
             msg "Can't find $Z!!!"
         fi
     done
    )
}
