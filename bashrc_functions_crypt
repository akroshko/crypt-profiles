#!/bin/bash
#
# Copyright (C) 2016, Andrew Kroshko, all rights reserved.
#
# Author: Andrew Kroshko
# Maintainer: Andrew Kroshko <akroshko.public+devel@gmail.com>
# Created: Tue May 25, 2016
# Version: 20160716
# URL: https://github.com/akroshko/bash-stdlib
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see http://www.gnu.org/licenses/.

################################################################################
# dealing with keys and agents

# TODO: don't think I need to specify working profile, can I do better? do I just need a temp working profile?
crypt-create-profile () {
    # TODO: what does a crypt-profile actually look like
    #       -master, original one, used for creating subkeys
    #       -primary, contains the files that get synced
    #       -working, gpg working directory, things are symlinked into here
    #       authorized_keys and public keys, figure out how to manage
    # TODO: ensure all public keys are mutually imported appropriately
    #       need a proper way to detect key profiles? do I want public keys mutually imported everywhere?
    #       put somewhere universal and import everywhere?
    # TODO: also manage disk and container LUKS encryption keys
    #
    # TODO: not robust enough yet, absolutely need to retry in case of
    # unusable public key for encryption
    #
    # TODO: automate a bit better
    #
    # References:
    #   http://spin.atomicobject.com/2013/10/23/secure-gpg-keys/
    #   http://spin.atomicobject.com/2013/11/24/secure-gpg-keys-guide/
    local USAGE="crypt-create-profile <<master location>> <<primary location>> <<working location>>"
    if [[ -z "$1" ]]; then
        yell "Empty master location specified!"
        return 1
    fi
    if [[ -z "$2" ]]; then
        yell "Empty primary location specified!"
        return 1
    fi
    if [[ -z "$3" ]]; then
        yell "Empty working location specified!"
        return 1
    fi
    killall-agents
    local MASTERPROFILE="$1"
    mkdir -p "${MASTERPROFILE}"
    fix-crypt-permissions "${MASTERPROFILE}"
    # do no make this directory because we use cp
    local PRIMARYPROFILE="$2"
    local WORKINGPROFILE="$3"
    # generate a new gpg key first
    # first ask for a the master password
    # XXXX: this is insecure but I need to use the password further in the script?
    # TODO: use pinentry to get password
    msg "++++ WARNING: password shown in cleartext for now and must be the same as that entered into pinentry later."
    msg "Enter the new GPG key password:"
    read GPGPASSWORD
    msg "Enter the new GPG key password again:"
    read GPGPASSWORD2
    msg "Enter the recipient:"
    read RECIPIENT
    if [[ ! "$GPGPASSWORD" == "$GPGPASSWORD2" ]]; then
        warn "Passwords are different!!!"
        return 1
    fi
    # XXXX: if true for debugging purposes
    if true; then
        h1
        h2 "Generating initial key:"
        msg "Recommend RSA (set your own capabilities), toggle until only capability is certify, 4096 bits, no expiry for now."
        # is it useful to have a special phrase in comment?
        # echo "Comment should include phrase ..."
        echo ""
        # TODO: retry if fail to build public key, e.g., password is bad
        DISPLAY= gpg-batch --homedir "$MASTERPROFILE" --expert --gen-key
        # put gpg password into the secrets file
        DISPLAY= echo ${GPGPASSWORD} | gpg-batch --homedir "$MASTERPROFILE" --recipient ${RECIPIENT} --encrypt --passphrase "$GPGPASSWORD" --output ${KEYSLOCATION}/secrets.txt.gpg -
        # add a new subkey to the master profile
        h1
        msg "Use the addkey command twice:"
        msg "Recommend RSA (set your own capabilities), toggle until only capability is sign, 4096 bits, no expiry for now."
        msg "Recommend RSA (set your own capabilities), toggle until only capability is encrypt, 4096 bits, no expiry for now."
        msg "Use the save command to finish"
        echo ""
        # TODO: retry if fail
        DISPLAY= gpg-batch --homedir "$MASTERPROFILE" --expert --edit-key "${RECIPIENT}"
    fi
    # XXXX: if true for debugging purposes
    if true; then
        # generate ssh keys, possibly want this to be a little better
        # TODO: setup authorized keys later, maybe have a way to see who can mutually login to whom
        # generate a password for id_rsa
        local PASSWORD=$(super-password)
        # create the ssh key
        ssh-keygen-rsa "$MASTERPROFILE" "$PASSWORD"
        # use gpg key to encrypt the password
        DISPLAY= echo "$PASSWORD" | gpg-batch --homedir "$MASTERPROFILE" --recipient ${RECIPIENT} --encrypt --passphrase "$GPGPASSWORD" --output "$MASTERPROFILE"/id_rsa.txt.gpg -
        # generate a password id_ed25519
        local PASSWORD=$(super-password)
        # create the ssh key
        ssh-keygen-ed25519 "$MASTERPROFILE" "$PASSWORD"
        # use gpg key to encrypt the password
        DISPLAY= echo "$PASSWORD" | gpg-batch --homedir "$MASTERPROFILE" --recipient ${RECIPIENT} --encrypt --passphrase "$GPGPASSWORD" --output "$MASTERPROFILE"/id_ed25519.txt.gpg -
    fi
    # XXXX: if true for debugging purposes
    if true; then
        cp -r "$MASTERPROFILE" "$WORKINGPROFILE"
        fix-crypt-permissions "${WORKINGPROFILE}"
        gpg-batch --homedir "$WORKINGPROFILE" --export-secret-subkeys "$RECIPIENT" > "${HOME}"/crypt-profiles-secret-keys
        h1
        msg "Answer (y)es to delete secret key"
        echo ""
        gpg2 --homedir "$WORKINGPROFILE" --delete-secret-key "$RECIPIENT"
        gpg2 --homedir "$WORKINGPROFILE" --import "${HOME}"/crypt-profiles-secret-keys
        # create the actually working profile
        # TODO: add some checks here
        mkdir -p "$PRIMARYPROFILE"
        mv "$WORKINGPROFILE"/pubring.gpg "$PRIMARYPROFILE"
        ln -s "$PRIMARYPROFILE"/pubring.gpg "$WORKINGPROFILE"/pubring.gpg
        mv "$WORKINGPROFILE"/secring.gpg "$PRIMARYPROFILE"
        ln -s "$PRIMARYPROFILE"/secring.gpg "$WORKINGPROFILE"/secring.gpg
        mv "$WORKINGPROFILE"/trustdb.gpg "$PRIMARYPROFILE"
        ln -s "$PRIMARYPROFILE"/trustdb.gpg "$WORKINGPROFILE"/trustdb.gpg
        mv "$MASTERPROFILE"/id_rsa.txt.gpg "$PRIMARYPROFILE"
        mv "$MASTERPROFILE"/id_rsa "$PRIMARYPROFILE"
        mv "$MASTERPROFILE"/id_rsa.pub "$PRIMARYPROFILE"
        mv "$MASTERPROFILE"/id_ed25519.txt.gpg "$PRIMARYPROFILE"
        mv "$MASTERPROFILE"/id_ed25519 "$PRIMARYPROFILE"
        mv "$MASTERPROFILE"/id_ed25519.pub "$PRIMARYPROFILE"
        # TODO: not sure I need this or where the best place is
        # fix-gpg-ssh-permissions
    fi
}

# TODO: will eventually want to be able to modify secret files
# TODO: want to be able to list and delete secrets too
# TODO: make sure this aborts properly
# TODO: have a more universal way of doing this
crypt-add-secret-to-profile () {
    # TODO: this is kind of a standard thing
    # TODO: add check that current profile and locations sync up
    # TODO: check that crypt is working
    if [[ -z "$1" ]]; then
        yell "Empty primary location specified!"
        return 1
    fi
    if [[ -z "$2" ]]; then
        yell "Empty secret name specified!"
        return 1
    fi
    # XXXX: must keep crypt active, possibly fix permissions
    local PRIMARYPROFILE="$1"
    local SECRETNAME="$2"
    # TODO: can I do this without??? maybe secrets should be symmetrically encrypted
    local RECIPIENT="$CRYPTGPGUSER"
    # enter secret
    msg "++++ WARNING: secret will be shown in cleartext."
    msg "Enter the secret on one line: "
    read THESECRET
    msg "Enter the secret again on one line: "
    read THESECRET2
    if [[ ! "$THESECRET" == "$THESECRET2" ]]; then
        warn "The secrets are different!!!"
        return 1
    fi
    # get the password from the current secrets
    local GPGPASSPHRASE=$(gpg-batch --decrypt ~/.secrets/secrets.txt.gpg 2>/dev/null | head -n 1)
    # create the secret
    if [[ -n "${THESECRET}" && -n "${RECIPIENT}" && -n "$GPGPASSPHRASE" && -n "$SECRETNAME" ]]; then
        # TODO: there is an issue with message "You need a passphrase to unlock the secret key for "
        #       issue temporarily solved by using --batch when decrypting
        echo ${THESECRET} | gpg2 --recipient "${RECIPIENT}" --encrypt --passphrase "${GPGPASSPHRASE}" --output "$PRIMARYPROFILE"/"$SECRETNAME"-secrets.txt.gpg -
    else
        yell "Something went wrong before final encryption!"
    fi
}

crypt-replace-subkeys () {
    yell "Not implemented yet!"
    false
}

crypt-profile-switch () {
    # switch to a new crypt-profile-
    local USAGE="Usage: crypt-profile-switch <<crypt-profile primary location>> <<crypt-profile working location>>"
    if [[ -z "$1" ]]; then
        yell "No specified primary path!"
        echo $USAGE
        return 1
    fi
    if [[ -z "$2" ]]; then
        yell "No specified working path!"
        echo $USAGE
        return 1
    fi
    # need library hardcoded
    source "${HOME}"/.bash_library
    # kill symlinks by default, send to all child processes
    local PRIMARYPROFILE="$1"
    local WORKINGPROFILE="$2"
    # create crypt-profiles automatically
    mkdir -p "$WORKINGPROFILE"
    # get rid of agents
    killall-agents
    # gpg symlinks
    if [[ -e "${HOME}"/.gnupg ]]; then
        \mv --backup=t -- "${HOME}"/.gnupg "${HOME}"/.gnupg.backup
    fi
    # make sure things are synced
    need_new_symlink "$PRIMARYPROFILE"/pubring.gpg "$WORKINGPROFILE"/pubring.gpg
    need_new_symlink "$PRIMARYPROFILE"/secring.gpg "$WORKINGPROFILE"/secring.gpg
    need_new_symlink "$PRIMARYPROFILE"/trustdb.gpg "$WORKINGPROFILE"/trustdb.gpg
    need_new_symlink "$WORKINGPROFILE" "${HOME}"/.gnupg
    # link to the secrets files
    need_new_directory "${HOME}"/.secrets
    # a loop to create symlinks
    for THESECRETFILE in $PRIMARYPROFILE/*; do
        [[ $THESECRETFILE =~ secrets || $THESECRETFILE =~ openvpn ]]  || continue
        need_new_symlink "$THESECRETFILE" "${HOME}"/.secrets/$(basename $THESECRETFILE)
    done
    # XXXX: just use secrets for itself, use last word in directory
    # TODO: document this and possibly make a better way to do this
    need_new_symlink "$PRIMARYPROFILE"/secrets.txt.gpg "${HOME}"/.secrets/$(basename ${PRIMARYPROFILE##*-}).txt.gpg
    need_new_symlink "$PRIMARYPROFILE"/id_rsa.txt.gpg "${HOME}"/.secrets/id_rsa.txt.gpg
    need_new_symlink "$PRIMARYPROFILE"/id_ecdsa.txt.gpg "${HOME}"/.secrets/id_ecdsa.txt.gpg
    need_new_symlink "$PRIMARYPROFILE"/id_ed25519.txt.gpg "${HOME}"/.secrets/id_ed25519.txt.gpg
    # ssh symlinks
    # TODO: what to do if something other than symlinks exists?
    need_new_symlink "$PRIMARYPROFILE"/id_ecdsa "${HOME}"/.ssh/id_ecdsa
    need_new_symlink "$PRIMARYPROFILE"/id_ecdsa.pub "${HOME}"/.ssh/id_ecdsa.pub
    need_new_symlink "$PRIMARYPROFILE"/id_ed25519 "${HOME}"/.ssh/id_ed25519
    need_new_symlink "$PRIMARYPROFILE"/id_ed25519.pub "${HOME}"/.ssh/id_ed25519.pub
    need_new_symlink "$PRIMARYPROFILE"/id_rsa "${HOME}"/.ssh/id_rsa
    need_new_symlink "$PRIMARYPROFILE"/id_rsa.pub "${HOME}"/.ssh/id_rsa.pub
    # TODO: may be an obsolete lines
    # need_new_symlink "$PRIMARYPROFILE"/authorized_keys ~/.ssh/authorized_keys
    need_new_symlink "$CRYPTSSHCONFIGPATH"/config "${HOME}"/.ssh/config
    # for scripts that modify .ssh/config, ensure there always an original
    need_new_symlink "$CRYPTSSHCONFIGPATH"/config "${HOME}"/.ssh/config_fallback
    need_new_symlink "$CRYPTGPGCONFIGPATH"/gpg.conf "${HOME}"/.gnupg/gpg.conf
    need_new_symlink "$CRYPTGPGCONFIGPATH"/gpg-agent.conf "${HOME}"/.gnupg/gpg-agent.conf
    fix-gpg-ssh-permissions
}

# TODO: actually do this
crypt-profile-backup () {
    false
}

crypt-profile-printable () {
    # TODO: need actual "$1" argument and to sort out whether master,primary,working
    # TODO: not $KEYSLOCATION variable
    # create a printable version of the profile, only print appropriate things
    if [[ -f "${KEYSLOCATION}"/pubring.gpg ]]; then
        local NAMES=()
        # get all gpg public keys ids
        while read LINE; do
            local REGEX='uid[[:space:]](.*)'
            if [[ "${LINE}" =~ $REGEX ]]; then
                NAMES+=( "${BASH_REMATCH[1]}" )
            fi
        done < <(gpg --list-keys --keyid-format 0xlong --no-default-keyring --keyring ${KEYSLOCATION}/pubring.gpg)
        # now get name and fingerprint for all keyids
        for NAME in "${NAMES[@]}"; do
            # echo "here"
            # echo "${NAME}"
            # echo $(gpg --list-keys --fingerprint --keyid-format 0xlong --no-default-keyring --keyring ${KEYSLOCATION}/pubring.gpg "${NAME}")
            # echo "there"
            local STRIPNAME=`echo "$NAME" | sed -e 's/^ *//g' -e 's/ *$//g' `
            local KEYIDS=()
            while read LINE; do
                local REGEXID='0x([0-9A-Z]{16})'
                local REGEXFINGER='Key fingerprint = (.*)'
                if [[ "$LINE" =~ $REGEXID ]]; then
                    KEYIDS+=( "${BASH_REMATCH[1]}" )
                elif [[ "$LINE" =~ $REGEXFINGER ]]; then
                    # TODO: does this line always run?
                    local KEYFINGERPRINT="${BASH_REMATCH[1]}"
                fi
            done < <(gpg --list-keys --fingerprint --keyid-format 0xlong --no-default-keyring --keyring ${KEYSLOCATION}/pubring.gpg "${NAME}")
            # get the ascii representation of the key
            for KEYID in ${KEYIDS[@]}; do
                # output printable versions of the keys
                # TODO any reason to output just fingerprints... useful without public key?
                echo -n "" > "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--public.txt
                echo -n "" > "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--private.txt
                echo ${NAME} >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--public.txt
                echo ${NAME} >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--private.txt
                echo "" >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--public.txt
                echo "" >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--private.txt
                echo ${KEYID} >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--public.txt
                echo ${KEYID} >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--private.txt
                echo "" >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--public.txt
                echo "" >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--private.txt
                echo ${KEYFINGERPRINT} >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--public.txt
                echo ${KEYFINGERPRINT} >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--private.txt
                echo "" >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--public.txt
                echo "" >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--private.txt
                gpg2 --export -a "${KEYID}" >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--public.txt
                gpg2 --export-secret-keys -a "${KEYID}" >> "${KEYSLOCATION}"/"${STRIPNAME}"--"${KEYID}"--private.txt
            done

            # echo "${NAME}"
            # echo "${KEYIDS[@]}"
            # echo "${KEYFINGERPRINTS[@]}"
            # echo "${KEYASCII}"
            # echo "${PRIVATEASCII}"
            # echo "================================================================================"
        done
    fi
}

killall-agents () {
    # kill all the agents and remove identifying information
    # XXXX: this is an incredibly crude way to reset, but works when nothing else does
    pkill -9 -f gpg-agent
    pkill -9 -f ssh-agent
    # XXXX: not completely desirable, but kill gnome keychain because it often interferes
    pkill -9 -f gnome-keyring-daemon
    # this is hopefully enough to purge it
    if [[ -e "${HOME}"/.gnupg/gpg-agent-info-$(hostname) ]]; then
        rm "${HOME}"/.gnupg/gpg-agent-info-$(hostname)
    fi
    # TODO: not sure if I ever need this?
    if [[ -e "${HOME}"/.gpg-agent-info ]]; then
        rm "${HOME}"/.gpg-agent-info
    fi
    # TODO: delete only things I own?
    if find /tmp -iname "gpg-*" >/dev/null 2>&1; then
        rm /tmp/gpg-*
    fi
    find "${HOME}"/.keychain -type f -delete
}

harm-crypt () {
    # harm stands for harmonize and is a nice prefix I use
    # XXXX: this function is pretty brutal, but resets very well
    killall-agents
    source "${HOME}"/.bash_profile
    # TODO: decide if I really want this here like this, maybe use function?
    if ps -ef | grep "emacs --daemon" | grep -v grep >/dev/null && type -P launch-emacsclient >/dev/null 2>&1; then
        h2 "Re-initing Emacs!"
        launch-emacsclient noframe --eval "(cic:init-crypt)"
    fi
}

ssh-keygen-ed25519 () {
    # generate an ssh key in the current directory based on username and host

    # $1=full path to put the key in, current path if not specified
    # $2=password to use for key, will ask if not specified
    if [[ -z "$1" ]]; then
        local KEYPATH=./id_ed25519
    else
        local KEYPATH="$1"/id_ed25519
    fi
    if [[ -z "$2" ]]; then
        ssh-keygen -b 521 -t ed25519 -C "$(id -un)@$(hostname)-$(date --rfc-3339=date)" -f "${KEYPATH}"
    else
        local PASSWORD="$2"
        ssh-keygen -b 521 -t ed25519 -C "$(id -un)@$(hostname)-$(date --rfc-3339=date)" -P "${PASSWORD}" -f "${KEYPATH}"
    fi
}

ssh-keygen-rsa () {
    # generate an ssh key using RSA in the current directory based on username and host
    # XXXX: often used on older hosts or for things like github

    # $1=full path to put the key in, current path if not specified
    # $2=password to use for key, will ask if not specified
    if [[ -z "$1" ]]; then
        local KEYPATH=./id_rsa
    else
        local KEYPATH="$1"/id_rsa
    fi
    if [[ -z "$2" ]]; then
        ssh-keygen -b 4096 -t rsa -C "$(id -un)@$(hostname)-$(date --rfc-3339=date)" -f "${KEYPATH}"
    else
        local PASSWORD="$2"
        ssh-keygen -b 4096 -t rsa -C "$(id -un)@$(hostname)-$(date --rfc-3339=date)" -P "${PASSWORD}" -f "${KEYPATH}"
    fi
}

################################################################################
# temporary functions to create temporary keys for situtations of low
# security risk (initial install over a LAN)

# TOOD: test before documenting

bootstrap-temporary-ssh () {
    if [[ -z "$1" ]]; then
        yell "No host specified!"
        return 1
    fi
    # XXXX: only do this if an id_rsa does not already exist on host machine
    # create a temporary ssh key without a password, based on
    ssh-keygen -b 4096 -t rsa -C "Temporary key to login to $(hostname)-$(date --rfc-3339=date)" -f "${HOME}"/.ssh/id_rsa_temp
    # copy private key to the host machine
    ssh $(whoami)@"$1" mkdir -p "${HOME}"/.ssh
    scp "${HOME}"/.ssh/id_rsa_temp $(whoami)@"$1":"${HOME}"/.ssh/id_rsa
    scp "${HOME}"/.ssh/id_rsa_temp.pub $(whoami)@"$1":"${HOME}"/.ssh/id_rsa.pub
    chmod 600 "${HOME}"/.ssh/id_rsa_temp*
    # copy to authorized keys
    cat "${HOME}"/.ssh/id_rsa_temp.pub >> "${HOME}"/.ssh/authorized_keys
}

bootstrap-temporary-ssh-remove () {
    # delete specific one on specific host?
    # TODO: I should ask nicely before I do this
    # TODO: give some options for hosts?
    if [[ -z "$1" ]]; then
        yell "No host specified!"
        return 1
    fi
    # XXXX: only do this if an id_rsa does not already exist on host machine
    # delete on private key on host machine
    ssh $(whoami)@"$1" rm "${HOME}"/.ssh/id_rsa
    # delete public and authorized keys on this machine
    # TODO: clean up blank lines
    sed -i '/Temporary key to login/d' "${HOME}"/.ssh/authorized_keys
    # delete the keys themselves
    rm "${HOME}"/.ssh/id_rsa_temp "${HOME}"/.ssh/id_rsa_temp.pub
}

bootstrap-temporary-ssh-remove-all () {
    # delete public and authorized keys on this machine
    # fix up authorized keys
    # TODO: I should ask nicely before I do this
    # TODO: do I want to clear up authorized keys elsewhere
    sed -i '/Temporary key to login/d' "${HOME}"/.ssh/authorized_keys
    # delete the keys themselves
    sed -i '/^\s*$/d' "${HOME}"/.ssh/authorized_keys
    home-trash "${HOME}"/.ssh/id_rsa_temp
    home-trash "${HOME}"/.ssh/id_rsa_temp.pub
}

bootstrap-nuke-crypt-home () {
    # deletes (backs up?) any stuff hanging around
    home-trash "${HOME}"/.ssh/config
}

################################################################################
# encrypt and decrypt files

encrypt-file () {
    # encrypt a file using gpg, checks with user to ensure there are no errors before deleting original
    #
    # $1=file to encrypt
    # TODO: should this be moved to bashrc_functions_crypt_external?
    if [[ ! -e "$1" ]]; then
        yell "Must specify an actual file to encrypt!!!"
        return 1
    fi
    local NEWNAME="$(generate-uid)"
    tar -cvzf - "$1" | gpg2 --recipient "$CRYPTGPGUSER" --output "$NEWNAME".tgz.gpg --encrypt -
    msg "Exit status: $? || Pipe status: ${PIPESTATUS[*]}"
    # TODO: is this a good way of verifying shredded file?
    verify-operation "Encrypt OK? do you wish to delete the original? (y/n) " "Really keep original? (y/n) " "$1"
}

encrypt-file-password () {
    # encrypt a file with a password (to be put through
    # another channel) get the psk in plain text
    #
    # generally to transfer secret keys, things needed to bootstrap a
    # secret system, or other information once; after which the paper
    # is completely destroyed
    #
    # this methodlogy is used because one can take precautions to be
    # relatively confident that any comprimise of paper would be
    # suspected
    local TOPSECRET=$(super-password-easy)
    msg "Password is: $TOPSECRET"
    while read -r -t 0;do read -r; done;
    read -n 1 -s -r -p "Please write down the password and press any key to continue... "
    export TRYAGAIN=
    while [[ $TRYAGAIN != "y" ]]; do
        clear
        # TODO: not sure if I should really do this twice
        while read -r -t 0;do read -r; done;
        read -e -p "Re-enter password: " TOPSECRET1
        if [[ $TOPSECRET != $TOPSECRET1 ]]; then
            # TODO: try again
            warn "Password does not match!!! Write down again!!!"
            warn "Password is: $TOPSECRET"
            while read -r -t 0;do read -r; done;
            read -n 1 -s -r -p "Press any key to continue... "
            local TRYAGAIN="n"
            continue
        fi
        local TRYAGAIN=y
    done
    msg "Passwords recorded successfully!"
    local FILEUID="$(generate-uid)"
    msg "The file UID is: $FILEUID"
    tar -cvzf - "$1" | gpg2 --cipher-algo AES256 --passphrase "$TOPSECRET" --output "$FILEUID".tgz.gpg --symmetric -
    msg "Encryption finished!!! "
}

decrypt-file () {
    # decrypt a file encrypted using gpg into a temporary path and then move to the current path
    # uses the backup feature of mv to ensure files are never clobbered and operation is verified
    # by the user before deleting the original file
    #
    # $1=path of file to decrypt
    h1
    if [[ ! -e "$1" ]]; then
        yell "$1 is not a real file to decrypt!!!"
        return 1
    fi
    # create random tmp directory here
    local TMPPATH=$(mktemp -d -p .)
    msg "Decrypting $1 into ${TMPPATH}"
    # XXXX: assuming successful
    gpg-batch --decrypt "$1" | tar -xvzf - --directory "${TMPPATH}"
    msg "Exit status: $? || Pipe status: ${PIPESTATUS[*]}"
    \mv --backup=t -- ${TMPPATH}/* .
    # TODO: want to fail completely if not able to remove?
    rmdir "${TMPPATH}"
    verify-operation "Decrypt OK? Do you wish to delete the encrypted file? (y/n) " "Really keep encrypted? (y/n) " "$1"
}

decrypt-file-password () {
    h1
    if [[ ! -e "$1" ]]; then
        yell "$1 is not a real file to decrypt!!!"
        return 1
    fi
    local TMPPATH=$(mktemp -d -p .)
    msg "Decrypting $1 into ${TMPPATH}"
    gpg-batch --decrypt "$1" | tar -xvzf - --directory "${TMPPATH}"
    msg "Exit status: $? || Pipe status: ${PIPESTATUS[*]}"
    \mv --backup=t -- ${TMPPATH}/* .
    # TODO: want to fail completely if not able to remove?
    rmdir "${TMPPATH}"
}

decrypt-flatten () {
    # go over all files in a directory and decrypt them into the current directory
    # TODO: this function in particular should also mv everything from subdirectories into current directory
    for fname in $PWD/*; do
        if [[ "$fname" =~ tgz.gpg$ ]]; then
            # decrypt file and delete (or trash)
            decrypt-file "$fname"
        fi
    done
}

################################################################################
# containers

mount-container () {
    # mount an encrypted luks container on an appropiate mount point
    #
    local USAGE="Usage: mount-container <<luks container path>> <<mount point>>

  <<luks container path>> the path to the luks container, the filename
    of the container is the same name used for the mapping in /dev/mapper

  <<mount point>> mount point to create and use"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE"
        return 1
    fi
    if [[ ! -e /dev/mapper/"$(basename $1)" ]]; then
        msg "Opening $(basename "$1")!"
        sudo cryptsetup luksOpen "$1" "$(basename $1)"
    else
        warn "Container $(basename $1) is already mapped!"
        true
    fi
    # TODO: add more error checking?
    if [[ $? != 4 ]]; then
        sudo mkdir -p "$2"
        # TODO: do better than this
        if ! grep -qs "$2" /proc/mounts; then
            sudo mount /dev/mapper/"$(basename $1)" "$2"
            # TODO: should this be default
            sudo chown -R ${USER}:${USER} "$2"
        else
            warn "Mount point $2 already mounted!"
        fi
    else
        yell "Cannot find specified container"
    fi
}

umount-container () {
    # unmount an encrypted luks container by using exactly the same
    # arguments as mount-container
    #
    # $1=the path to the luks container, the filename of the container
    #    is the same name used for the mapping in /dev/mapper
    # $2=mount point, deleted after unmounting
    local USAGE="Usage: umount-container <<luks container path>> <<mount point>>

  <<luks container path>> the path to the luks container, the filename
    of the container is the same name used for the mapping in /dev/mapper

  <<mount point>> mount point to create and use"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE"
        return 1
    fi
    if [[ -d "$2" ]]; then
        if grep -qs "$2" /proc/mounts; then
            msg "Unmounting $2!"
            sudo umount "$2"
        else
            yell "Nothing mounted!"
        fi
        # XXXX: get rid of directory anyways
        rmdir "$2"
    else
        warn "Mount point $2 does not exist!"
    fi
    if [[ -e /dev/mapper/"$(basename $1)" ]]; then
        msg "Closing $(basename $1)!"
        sudo cryptsetup luksClose "$(basename $1)"
    else
        warn "Container "$(basename $1)" not mapped!"
    fi
}

open-vg () {
    # open a LVM volume group from an encrypted luks container
    local USAGE="Usage: open-vg <<luks container path>> <<volume group>>

  <<luks container path>> the path to the luks container, the filename of the container
    is the same name used for the mapping in /dev/mapper

  <<volume group>> the name of the volume group"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE"
        return 1
    fi
    if [[ -e "$1" ]]; then
        if [[ ! -e /dev/mapper/$(basename "$1") ]]; then
            msg "Opening $(basename "$1")!"
            sudo cryptsetup luksOpen "$1" $(basename "$1")
        else
            warn "Device /dev/mapper/$(basename "$1") already mapped!"
        fi
        # TODO: should I still activate volumes anyways, even if already mapped?
        sudo vgchange -a y "$2"
    else
        warn "Image $1 not found!"
    fi
}

open-vg-maintenance () {
    # open a LVM volume group from an encrypted luks container
    # TODO: combine code?
    local USAGE="Usage: open-vg-maintenance <<luks container path>> <<volume group>>

  <<luks container path>> the path to the luks container, the filename of the container
    is the same name used for the mapping in /dev/mapper

  <<volume group>> the name of the volume group"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE"
        return 1
    fi
    if [[ -e "$1" ]]; then
        if [[ ! -e /dev/mapper/$(basename "$1") ]]; then
            msg "Opening $(basename "$1")!"
            sudo cryptsetup luksOpen "$1" $(basename "$1")
        else
            warn "Device /dev/mapper/$(basename "$1") already mapped!"
        fi
        # TODO: warn if already mapped
    else
        warn "Image $1 not found!"
    fi
}

vg-container-expand () {
    # https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_a_non-root_file_system#Resizing_the_loopback_filesystem
    # XXXX: highly recommend having a backup here and not rerunning if it fails!
    # XXXX: not thoroughly tested!!!!
    # TODO: would like to enter password once at beginning
    # TODO: want better error checking ahead of time
    local USAGE="Usage: vg-container-expand <<luks container path>> <<size to add>>

  <<luks container path>> the path to the luks container, the filename of the container
    is the same name used for the mapping in /dev/mapper

  <<size to add>> the number of gb to add"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE"
        return 1
    fi
    while read -r -t 0;do read -r; done;
    read -n 1 -p "This is a dangerous and poorly tested function!!! Continue (y/n)? " yn
    echo ""
    if [[ $yn == "y" ]];then
        local CONTAINER="$1"
        local SIZEADD="$2"
        if [[ -e "$CONTAINER" ]]; then
            # expand the container file itself, this is irreversible
            # TODO: 80G takes about ??? use my better functions that use openssl
            # dd if=/dev/urandom bs=1M count="$SIZEADD" | cat - >> "$CONTAINER"
            write-random-data-stdout "$SIZEADD" | cat - >> "$CONTAINER"
            # mount the encrypted container to resize (does this have to happen on loopback)
            sudo cryptsetup luksOpen "$CONTAINER" "$(basename $CONTAINER)"
            sudo cryptsetup resize "$(basename $CONTAINER)"
            # expand the physical volume
            sudo /sbin/pvresize /dev/mapper/"$(basename $CONTAINER)"
            # finally close everything down
            # TODO: not quite working yet, how do I know archive name to close it down properly?
            #       do I even need to do this
            sudo vgchange -a n /dev/mapper/"$(basename $CONTAINER)"
            sudo cryptsetup luksClose "$(basename $CONTAINER)"
        else
            yell "Container does not exist!!!"
        fi
    fi
}

close-vg () {
    # close a LVM volume group from an encrypted luks container
    # uses the same set of arguments as open-vg
    local USAGE="Usage: close-vg <<luks container path>> <<volume group>>

  <<luks container path>> the pathcase
 to the luks container, the filename of the container
    is the same name used for the mapping in /dev/mapper

  <<volume group>> the name of the volume group"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE"
        return 1
    fi
    if [[ -e /dev/mapper/$(basename "$1") ]]; then
        sudo vgchange -a n "$2"
        msg "Closing $(basename $1)!"
        sudo cryptsetup luksClose $(basename "$1")
    else
        warn "Device $1 does not exist!"
    fi
}

mount-vg-img () {
    # mount an encrypted luks container from an encrypted luks LVM image
    local USAGE="Usage: mount-vg-img <<volume group>> <<mount point>>

  <<volume group>> name of the volume group

  <<mount point>>  mount point to create and use"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE"
        return 1
    fi
    if [[ -e /dev/mapper/"$1" ]]; then
        msg "Opening $(basename "$2")!"
        sudo cryptsetup luksOpen /dev/mapper/"$1" $(basename "$2")
    else
        warn "Device /dev/mapper/$1 already mapped!"
    fi
    if ! grep -qs "$2" /proc/mounts; then
        mkdir -p "$2"
        sudo mount /dev/mapper/$(basename "$2") "$2"
        sudo chown -R ${USER}:${USER} "$2"
    else
        warn "Device /dev/mapper/$1 already mounted!"
    fi
}

umount-vg-img () {
    # unmount an encrypted luks container from an encrypted luks LVM
    # image by using exactly the same arguments as mount-vg-img
    local USAGE="Usage: umount-vg-img <<volume group>> <<mount point>>

  <<volume group>> name of the volume group

  <<mount point>>  mount point that is deleted after unmounting"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "$USAGE"
        return 1
    fi
    if [[ -d "$2" ]]; then
        # TODO: seperate function?
        if grep -qs "$2" /proc/mounts; then
            msg "Unmounting $2!"
            sudo umount "$2"
        else
            warn "Nothing mounted!"
        fi
        # XXXX: get rid of directory anyways
        rmdir "$2"
    fi
    if [[ -e /dev/mapper/$(basename "$2") ]]; then
        msg "Closing $(basename $2)!"
        sudo cryptsetup luksClose "$(basename $2)"
    else
        warn "Container "$(basename $2)" not mapped!"
    fi
}

################################################################################
# system maintenance functions

kill-recent-files-line () {
    # XXXX: dangerous functions for convenience in batch mode
    # TODO: want to make this more general
    if [[ -f "$1" ]]; then
        sed -i '/\[Recent Files\]/,/^\s*$/{d}' "$1"
    fi
}

export-firefox-bookmarks () {
    # http://www.commandlinefu.com/commands/view/14088/get-your-firefox-bookmarks
    # XXXX: used before deleting places.sqlite, because that's a cool thing to do, and put any bookmarks in text file
    # TODO: do similarily terrible things elsewhere
    # TODO: test if there is an sqllite
    sqlite3 ~/.mozilla/firefox/*.[dD]efault/places.sqlite "SELECT strftime('%d.%m.%Y %H:%M:%S', dateAdded/1000000, 'unixepoch', 'localtime'),url FROM moz_places, moz_bookmarks WHERE moz_places.id = moz_bookmarks.fk ORDER BY dateAdded;"
}

master-privacy-brief () {
    # XXXX: suppress automatic privacy clearing if needed
    if [[ -e "$HOME"/inhibit-privacy ]]; then
        yell "Privacy cleanup suppressed!!!"
    else
        # delete benign things, that shouldn't cause too much trouble
        # XXXX: seems to cause issues with long downloads in firefox
        # TODO: are things running that I don't want to clear privacy for
        if ! ps -ef | grep "conkeror" | grep -v grep >/dev/null; then
            master-privacy --batch
            echo "$(date-time-stamp) Success" >> "$HOME/.myprivacy.log"
        else
            warn "Programs running! Will do later!"
            echo "$(date-time-stamp) Delayed" >> "$HOME/.myprivacy.log"
        fi
    fi
}

master-privacy-all () {
    # XXXX: requires crypt-profiles to be in path
    sudo env "PATH=$PATH" master-privacy-all.sh "${USER}"
}

master-privacy () {
    time {
        # TODO: any argument will do, not just --batch
        if [[ -z "$1" ]]; then
            h1 "Delete things that need user input"
            while read -r -t 0;do read -r; done;
            # TODO: check if an sqllite exists before asking
            read -n 1 -p "Do you want to delete all Firefox places.sqllite? (y/n) " ynfirefox
            echo ""
            h2 "Clearing trash"
            if [[ -d "${HOME}"/tmp/trash ]] && ls -A "${HOME}"/tmp/trash/* >/dev/null 2>&1; then
                msg  "Contents of ~/tmp/trash:"
                ls -A "${HOME}"/tmp/trash/*
                while read -r -t 0;do read -r; done;
                read -n 1 -p "Do you want to delete ~/tmp/trash? (y/n) " yn
                echo ""
                if [[ "$yn" =~ y ]]; then
                    # TODO: add a countdown here
                    kill-directory-contents "${HOME}"/tmp/trash
                fi
            else
                warn "Nothing in ~/tmp/trash"
            fi
            if [[ -d "${HOME}"/.local/share/Trash/files ]] && ls -A -d "${HOME}"/.local/share/Trash/files/* >/dev/null 2>&1; then
                msg "Contents of ~/.local/share/Trash/files:"
                ls -A "${HOME}"/.local/share/Trash/files
                # TODO: check if empty?
                while read -r -t 0;do read -r; done;
                read -n 1 -p "Do you want to delete ~/.local/share/Trash/files? (y/n) " yn
                echo ""
                if [[ "$yn" =~ y ]]; then
                    bleachbit --overwrite --clean system.trash
                    # TODO: add a countdown here
                    # kill-directory-contents "${HOME}"/.local/share/Trash/files
                    # kill-directory-contents "${HOME}"/.local/share/Trash/info
                fi
            else
                warn "Nothing in "${HOME}"/.local/share/Trash/files"
            fi
            # XXXX: these are specific to other unreleased scripts I have
            h1 "Automatically deleting temporary files"
            for tmplocation in "${HOME}"/tmp/*; do
                [[ -d "$tmplocation" ]] || continue
                # if [[ "$tmplocation" =~ flattened || "$tmplocation" =~ thumbnail ]]; then
                # TODO: do not delete thumbnail for now, decide later
                if [[ "$tmplocation" =~ flattened ]]; then
                    # do not allow .git directories to be mirrored then shredded, causes issues with shredding hardlinks
                    if [[ -z "$(find $tmplocation -iname \"*.git\" -type d)" ]]
                    then
                        msg "Killing $tmplocation"
                        kill-recursive "$tmplocation"
                    else
                        warn "The location $tmplocation appears to contain git repos!!!"
                    fi
                fi
            done
            local IMAGETMP=""${HOME}"/tmp/image-tmp"
            if [[ -d  "${IMAGETMP}" ]]; then
                if [[ -n "$(find $tmplocation -iname \"*.git\" -type d)" ]]; then
                    msg "Killing ${IMAGETMP}"
                    kill-recursive "${IMAGETMP}"
                else
                    warn "The location $IMAGETMP appears to contain git repos!!!"
                fi

            fi
        fi
        # TODO: reset so gnome does not give errors
        h1 "Bleachbit browsers"
        h2 "Chromium"
        # XXXX: I only use chromium as a secondary browser, decided to just shred everything
        if ! check-chromium; then
            bleachbit --shred "${HOME}"/.config/chromium/
            bleachbit --shred "${HOME}"/.cache/chromium/
        else
            warn "Chromium running!"
        fi
        # chromium.form_history
        h2 "Firefox"
        if ! check-firefox; then
            # XXXX: this preserves any bookmarks
            bleachbit --overwrite --clean firefox.backup firefox.cache firefox.crash_reports firefox.forms firefox.download_history firefox.session_restore firefox.url_history firefox.vacuum
        fi
        #
        # TODO: do I still want to ask?
        if [[ "$ynfirefox" =~ y ]]; then
            # TODO: terrible way to do this
            if export-firefox-bookmarks >/dev/null; then
                export-firefox-bookmarks >> ~/Downloads/firefox-bookmarks-$(date-time-stamp).txt
            else
                warn "Cannot export Firefox bookmarks, places.sqlite probably does not exist!"
            fi
            # XXXX: this kills all bookmarks
            kill-find-matching ""${HOME}"/.mozilla/firefox places.sqlite"
            bleachbit --shred ""${HOME}"/.mozilla/firefox/Crash Reports"
        else
            warn "Firefox running or not clearing due to no input.!"
        fi
         # TODO: ask to delete filefox places due to bug
        # bleachbit --overwrite --clean
        h2 "Flash"
        bleachbit --overwrite --clean flash.*
        # secondary browsers
        h2 "Google Chrome, Konqueror, Epiphany, and Elinks"
        bleachbit --overwrite --clean elinks.* epiphany.* google_chrome.* konqueror.*
        h2 "Conkeror"
        # XXXX: I now use a password manager and just clear everything
        if ! check-firefox; then
            if [[ -d "${HOME}"/.conkeror.mozdev.org/ ]]; then
                msg "Clearing firefox-based browsers OK!"
                # XXXX: preserve as much as possible, like adblocker
                # TODO: keep shredding more
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror content-prefs.sqlite
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror cookies.sqlite
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror cookies.sqlite-shm
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror cookies.sqlite-wal
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror datareporting
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror downloads.json
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror formhistory.sqlite
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror mimeTypes.rdf
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror permissions.sqlite
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror places.sqlite
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror places.sqlite-shm
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror places.sqlite-wal
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror prefs.js
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror sessionCheckpoints.json
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror saved-telemetry-pings
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror storage
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror webappsstore.sqlite
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror webappsstore.sqlite-shm
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror webappsstore.sqlite-wal
                kill-find-matching "${HOME}"/.conkeror.mozdev.org/conkeror xulstore.json
                # cache files
                bleachbit --shred "${HOME}"/.cache/conkeror.mozdev.org/
                bleachbit --shred "${HOME}"/.cache/firefox/
                bleachbit --shred "${HOME}"/.cache/mozilla/
            fi
        else
            warn "Firefox or similar running!"
        fi
        h1 "Bleachbit system"
        h2 "Recent application files"
        # TODO: be as severe as possible on anything I don't use
        bleachbit --overwrite --clean adobe_reader.* amsn.* amule.* audacious.* easytag.* evolution.* filezilla.* gedit.* google_chrome.* google_earth.* google_toolbar.* gwenview.* java.* openofficeorg.* pidgin.* realplayer.* rhythmbox.* skype.* thunderbird.* vlc.*
        h2 "Gnome"
        bleachbit --overwrite --clean gnome.* nautilus.*
        h2 "KDE"
        bleachbit --shred "${HOME}"/.kde/share/apps/RecentDocuments/*
        bleachbit --overwrite --clean kde.*
        kill-directory-contents "${HOME}"/.kde/share/apps/okular/docdata
        kill-directory-contents "${HOME}"/.kde/share/apps/kconf_update/log
        h2 "System-wide"
        # TODO: reinstate these
        # XXXX: not system.tmp!!! interferes with many many things
        bleachbit --overwrite --clean system.cache system.clipboard system.recent_documents thumbnails.*
        # destroy files that could leak privacy data
        # XXXX: this is a dangerous function that really nukes everything!!!
        # TODO: do I want umount-all type-function here?
        # TODO: replace as much as possible with bleachbit
        # TODO: do better job at this?
        # clean out recently used lists
        h2 "Clearing recently used"
        kill-file "${HOME}"/.recently-used
        # kill-file ~/.config/epiphany/ephy-history.db
        kill-file "${HOME}"/.config/gxine/playlist
        # causes problems on my system
        kill-file "${HOME}"/.config/mimeapps.list
        # XXXX: these are killed by bleachbit
        # kill-recursive ~/.local/share/*xbel*;
        kill-file-contents "${HOME}"/.local/share/user-places.xbel;
        kill-recent-files-line '/\[Recent Files\]/,/^\s*$/{d}' "${HOME}"/.kde/share/config/arkrc
        kill-matching-line '/Recent Urls/d' "${HOME}"/.kde/share/config/dragonplayerrc
        # kill-recent-files-line ~/.kde/share/config/gwenviewrc
        kill-recent-files-line "${HOME}"/.kde/share/config/katerc
        kill-recent-files-line "${HOME}"/.kde/share/config/okularrc
        # TODO: find out if these are really killed otherwise
        # h2  "Clearing tracker/indexers"
        # kill-directory-contents-preserve-structure "${HOME}"/.local/share/tracker;
        # kill-directory-contents "${HOME}"/.local/share/zeitgeist
        # kill-directory-contents ~/.kde/share/apps/gwenview/recentfolders/*
        # bleachbit --overwrite --clean thumbnails.cache
        # kill-directory-contents-preserve-structure ~/.cache/thumbnails
        # dragonplayer
        # ~/.kde/share/config/dragonplayerrc
        # https://unix.stackexchange.com/questions/192465/remove-paragraph-from-file
        # TODO: need a delete paragraph function
        # clear my personal trash
        # TODO: only kills dotfiles(dirs) if a normal file exists
        # only shred emacs files if interactive
        if [[ -z "$1" ]]; then
            # if ! check-emacs-daemon; then
            echo "Shredding temporary emacs files!"
            kill-directory-contents "${HOME}"/.emacs.d/tmp/
            kill-directory-contents "${HOME}"/.emacs.d/image-dired/
            # TODO: ask before this?
            kill-directory-contents "${HOME}"/.local/share/zathura
            if [[ -d "${HOME}"/.local/share/data/qpdfview ]]; then
                bleachbit --shred  "${HOME}"/.local/share/data/qpdfview
            fi
            if [[ -d "${HOME}"/.local/share/evolution ]]; then
                bleachbit --shred "${HOME}"/.local/share/evolution
            fi
            # TODO: possibly do less, so preserve vlc options
            kill-directory-contents "${HOME}"/.local/share/vlc
            kill-directory-contents "${HOME}"/.abobe
            kill-directory-contents "${HOME}"/.cr3
            # TODO: program I once tested, remove
            kill-directory-contents "${HOME}"/.viking
            kill-directory-contents "${HOME}"/.xine
            # TODO: if I seriouly use this, fix
            kill-directory-contents "${HOME}"/.openshot
            # TODO: if I seriouly use this, fix
            kill-directory-contents "${HOME}"/.mypaint
            # TODO: do I want this in batch mode or not
            #       can I just kill it and ones that look like it
            kill-file-contents "${HOME}"/.local/share/recently-used.xbel
            kill-file-contents "${HOME}"/.xsession-errors
            # TODO: want a robust kill matching files
            if [[ -d "${HOME}"/.local/share/ ]]; then
                find "${HOME}"/.local/share/ -maxdepth 1 -type f -iname "recently-used.xbel.*" -exec bleachbit --shred {} \;
            fi
            # TODO:
        fi
        h2 "Re-caching programs such as Sage and Python"
        # rerun/recomple python and sage if they exist, to restore cached stuff
        # TODO: should this be done elsewhere? function for this
        if type -P sage >/dev/null 2>&1; then
            echo "recache sage"
            time {
                sage -c "pass"
            }
        fi
        if type -P python >/dev/null 2>&1; then
            echo "recache python"
            time {
                python -c "pass"
            }
        fi
        if type -P ipython >/dev/null 2>&1; then
            time {
                echo "recache ipython"
                ipython -c "pass"
            }
        fi
    }
}

################################################################################
# misc

fix-sshd-config () {
    # make /etc/sshd_config more secure
    # uses guidelines given by https://stribika.github.io/2015/01/04/secure-secure-shell.html
    # XXXX: I think I just have this avoid accidental running most of the time
    if [[ ! -e "./sshd_config" && ! -e "./bashrc_functions_crypt" ]]; then
        yell "Must be run in crypt-profiles path."
        return 1
    fi
    sudo cp --backup=t /etc/ssh/sshd_config /etc/ssh/sshd_config.bak
    # edit my ssh block
    # delete my ssh block
    # TODO: deal with multiple copies
    sudo sed -i '/#+BEGIN crypt_profiles ssd_config block/,/#+END crypt-profiles ssd_config block/d' /etc/ssh/sshd_config
    # comment out lines I will replace
    sudo sed -e '/^Protocol/ s/^#*/# /'             -i /etc/ssh/sshd_config
    sudo sed -e '/^HostKey/ s/^#*/# /'              -i /etc/ssh/sshd_config
    sudo sed -e '/^Ciphers/ s/^#*/# /'              -i /etc/ssh/sshd_config
    sudo sed -e '/^MACs/ s/^#*/# /'                 -i /etc/ssh/sshd_config
    sudo sed -e '/^PermitRootLogin/ s/^#*/# /'      -i /etc/ssh/sshd_config
    sudo sed -e '/^UseDNS/ s/^#*/# /'               -i /etc/ssh/sshd_config
    sudo sed -e '/^GSSAPIAuthentication/ s/^#*/# /' -i /etc/ssh/sshd_config
    sudo sed -e '/^LoginGraceTime/ s/^#*/# /'       -i /etc/ssh/sshd_config
    sudo sed -e '/^AllowUsers/ s/^#*/# /'           -i /etc/ssh/sshd_config
    sudo sed -e '/^Subsystem/ s/^#*/# /'            -i /etc/ssh/sshd_config
    sudo sed -e '/^AllowTcpForwarding/ s/^#*/# /'            -i /etc/ssh/sshd_config
    # add my ssh block back
    sudo bash -c "echo '' >> /etc/ssh/sshd_config"
    sudo bash -c "cat ./sshd_config >> /etc/ssh/sshd_config"
    sudo bash -c "echo '' >> /etc/ssh/sshd_config"
    # eliminate double lines
    sudo sed -e '/^$/N;/^\n$/D'                     -i /etc/ssh/sshd_config
    sudo service ssh restart
}

ssh-crypt-profile-batch-cmd () {
    # ssh into hostname without interaction by using secrets on current host
    # ssh-crypt-profile-batch-cmd <<hostname>> <<crypt-profile name>> <<command>>
    local PWDFILE=~/.secrets/"$2".txt.gpg
    if [[ -f "$PWDFILE" ]]; then
        local TOPSECRET=$(DISPLAY= gpg-batch --no-tty --decrypt --use-agent "$PWDFILE")
        if [[ $? == 0 ]]; then
            local GPGPWD=$(sed -n '1p' <<< "$TOPSECRET")
            local B64COMMAND="$(echo "$3" | base64)"
            ssh-batch-interact $1 "source ~/.bash_profile $GPGPWD;source ~/.bash_libenv;bash -c \"$(echo ${B64COMMAND} | base64 -d)\""
        else
            echo "Error decrypting!!!"
        fi
    fi
}

crypt-luks-headers-dump () {
    sudo true
    (IFS=$'\n'
     for Z in $(lsblk -l -o name | tail -n +2); do
         if [[ -e /dev/"$Z" ]]; then
             local OUTPUT="$(sudo cryptsetup luksDump /dev/$Z 2>&1)"
             if [[ $? == 0 ]]; then
                 h2 /dev/"$Z"
                 echo "$OUTPUT"
             fi
         elif [[ -e /dev/mapper/"$Z" ]]; then
             local OUTPUT="$(sudo cryptsetup luksDump /dev/mapper/$Z 2>&1)"
             if [[ $? == 0 ]]; then
                 h2 /dev/mapper/"$Z"
                 echo "$OUTPUT"
             fi
         else
             msg "Can't find $Z!!!"
         fi
     done
    )
}

# TODO: generalize with above
crypt-luks-headers-backup-here () {
    sudo true
    (IFS=$'\n'
     # XXXX: | sort | uniq means only one of a raid arry gets it's luks headers gets backed up
     # TODO: make sure this is OK
     for Z in $(lsblk -l -o name | tail -n +2 | sort | uniq); do
         if [[ -e /dev/"$Z" ]]; then
             local OUTPUT="$(sudo cryptsetup luksDump /dev/$Z 2>&1)"
             if [[ $? == 0 ]]; then
                 h2 /dev/"$Z"
                 sudo cryptsetup luksHeaderBackup /dev/"$Z"        --header-backup-file=./luks-header-backup-${HOSTNAME}-"$Z"-$(date-time-stamp).bin
             fi
         elif [[ -e /dev/mapper/"$Z" ]]; then
             local OUTPUT="$(sudo cryptsetup luksDump /dev/mapper/$Z 2>&1)"
             if [[ $? == 0 ]]; then
                 h2 /dev/mapper/"$Z"
                 sudo cryptsetup luksHeaderBackup /dev/mapper/"$Z" --header-backup-file=./luks-header-backup-${HOSTNAME}-"$Z"-$(date-time-stamp).bin
             fi
         else
             msg "Can't find $Z!!!"
         fi
     done)
}
